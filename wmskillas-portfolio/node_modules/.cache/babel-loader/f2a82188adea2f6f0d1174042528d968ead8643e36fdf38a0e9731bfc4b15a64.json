{"ast":null,"code":"'use client';\n\nimport { createElement, forwardRef, useState, useEffect } from 'react';\n\n/**\n* Resolve icon set icons\n*\n* Returns parent icon for each icon\n*/\nfunction getIconsTree(data, names) {\n  const icons = data.icons;\n  const aliases = data.aliases || Object.create(null);\n  const resolved = Object.create(null);\n  function resolve(name) {\n    if (icons[name]) return resolved[name] = [];\n    if (!(name in resolved)) {\n      resolved[name] = null;\n      const parent = aliases[name] && aliases[name].parent;\n      const value = parent && resolve(parent);\n      if (value) resolved[name] = [parent].concat(value);\n    }\n    return resolved[name];\n  }\n  Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);\n  return resolved;\n}\n\n/**\n* Default values for dimensions\n*/\nconst defaultIconDimensions = Object.freeze({\n  left: 0,\n  top: 0,\n  width: 16,\n  height: 16\n});\n/**\n* Default values for transformations\n*/\nconst defaultIconTransformations = Object.freeze({\n  rotate: 0,\n  vFlip: false,\n  hFlip: false\n});\n/**\n* Default values for all optional IconifyIcon properties\n*/\nconst defaultIconProps = Object.freeze({\n  ...defaultIconDimensions,\n  ...defaultIconTransformations\n});\n/**\n* Default values for all properties used in ExtendedIconifyIcon\n*/\nconst defaultExtendedIconProps = Object.freeze({\n  ...defaultIconProps,\n  body: \"\",\n  hidden: false\n});\n\n/**\n* Merge transformations\n*/\nfunction mergeIconTransformations(obj1, obj2) {\n  const result = {};\n  if (!obj1.hFlip !== !obj2.hFlip) result.hFlip = true;\n  if (!obj1.vFlip !== !obj2.vFlip) result.vFlip = true;\n  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n  if (rotate) result.rotate = rotate;\n  return result;\n}\n\n/**\n* Merge icon and alias\n*\n* Can also be used to merge default values and icon\n*/\nfunction mergeIconData(parent, child) {\n  const result = mergeIconTransformations(parent, child);\n  for (const key in defaultExtendedIconProps) if (key in defaultIconTransformations) {\n    if (key in parent && !(key in result)) result[key] = defaultIconTransformations[key];\n  } else if (key in child) result[key] = child[key];else if (key in parent) result[key] = parent[key];\n  return result;\n}\n\n/**\n* Get icon data, using prepared aliases tree\n*/\nfunction internalGetIconData(data, name, tree) {\n  const icons = data.icons;\n  const aliases = data.aliases || Object.create(null);\n  let currentProps = {};\n  function parse(name$1) {\n    currentProps = mergeIconData(icons[name$1] || aliases[name$1], currentProps);\n  }\n  parse(name);\n  tree.forEach(parse);\n  return mergeIconData(data, currentProps);\n}\n\n/**\n* Extract icons from an icon set\n*\n* Returns list of icons that were found in icon set\n*/\nfunction parseIconSet(data, callback) {\n  const names = [];\n  if (typeof data !== \"object\" || typeof data.icons !== \"object\") return names;\n  if (data.not_found instanceof Array) data.not_found.forEach(name => {\n    callback(name, null);\n    names.push(name);\n  });\n  const tree = getIconsTree(data);\n  for (const name in tree) {\n    const item = tree[name];\n    if (item) {\n      callback(name, internalGetIconData(data, name, item));\n      names.push(name);\n    }\n  }\n  return names;\n}\n\n/**\n* Optional properties\n*/\nconst optionalPropertyDefaults = {\n  provider: \"\",\n  aliases: {},\n  not_found: {},\n  ...defaultIconDimensions\n};\n/**\n* Check props\n*/\nfunction checkOptionalProps(item, defaults) {\n  for (const prop in defaults) if (prop in item && typeof item[prop] !== typeof defaults[prop]) return false;\n  return true;\n}\n/**\n* Validate icon set, return it as IconifyJSON on success, null on failure\n*\n* Unlike validateIconSet(), this function is very basic.\n* It does not throw exceptions, it does not check metadata, it does not fix stuff.\n*/\nfunction quicklyValidateIconSet(obj) {\n  if (typeof obj !== \"object\" || obj === null) return null;\n  const data = obj;\n  if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") return null;\n  if (!checkOptionalProps(obj, optionalPropertyDefaults)) return null;\n  const icons = data.icons;\n  for (const name in icons) {\n    const icon = icons[name];\n    if (!name || typeof icon.body !== \"string\" || !checkOptionalProps(icon, defaultExtendedIconProps)) return null;\n  }\n  const aliases = data.aliases || Object.create(null);\n  for (const name in aliases) {\n    const icon = aliases[name];\n    const parent = icon.parent;\n    if (!name || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon, defaultExtendedIconProps)) return null;\n  }\n  return data;\n}\n\n/**\n* Storage by provider and prefix\n*/\nconst dataStorage = Object.create(null);\n/**\n* Create new storage\n*/\nfunction newStorage(provider, prefix) {\n  return {\n    provider,\n    prefix,\n    icons: Object.create(null),\n    missing: /* @__PURE__ */new Set()\n  };\n}\n/**\n* Get storage for provider and prefix\n*/\nfunction getStorage(provider, prefix) {\n  const providerStorage = dataStorage[provider] || (dataStorage[provider] = Object.create(null));\n  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\n/**\n* Add icon set to storage\n*\n* Returns array of added icons\n*/\nfunction addIconSet(storage, data) {\n  if (!quicklyValidateIconSet(data)) return [];\n  return parseIconSet(data, (name, icon) => {\n    if (icon) storage.icons[name] = icon;else storage.missing.add(name);\n  });\n}\n/**\n* Add icon to storage\n*/\nfunction addIconToStorage(storage, name, icon) {\n  try {\n    if (typeof icon.body === \"string\") {\n      storage.icons[name] = {\n        ...icon\n      };\n      return true;\n    }\n  } catch (err) {}\n  return false;\n}\n/**\n* List available icons\n*/\nfunction listIcons(provider, prefix) {\n  let allIcons = [];\n  const providers = typeof provider === \"string\" ? [provider] : Object.keys(dataStorage);\n  providers.forEach(provider$1 => {\n    const prefixes = typeof provider$1 === \"string\" && typeof prefix === \"string\" ? [prefix] : Object.keys(dataStorage[provider$1] || {});\n    prefixes.forEach(prefix$1 => {\n      const storage = getStorage(provider$1, prefix$1);\n      allIcons = allIcons.concat(Object.keys(storage.icons).map(name => (provider$1 !== \"\" ? \"@\" + provider$1 + \":\" : \"\") + prefix$1 + \":\" + name));\n    });\n  });\n  return allIcons;\n}\n\n/**\n* Expression to test part of icon name.\n*\n* Used when loading icons from Iconify API due to project naming convension.\n* Ignored when using custom icon sets - convension does not apply.\n*/\nconst matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\n/**\n* Convert string icon name to IconifyIconName object.\n*/\nconst stringToIcon = (value, validate, allowSimpleName, provider = \"\") => {\n  const colonSeparated = value.split(\":\");\n  if (value.slice(0, 1) === \"@\") {\n    if (colonSeparated.length < 2 || colonSeparated.length > 3) return null;\n    provider = colonSeparated.shift().slice(1);\n  }\n  if (colonSeparated.length > 3 || !colonSeparated.length) return null;\n  if (colonSeparated.length > 1) {\n    const name$1 = colonSeparated.pop();\n    const prefix = colonSeparated.pop();\n    const result = {\n      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n      prefix,\n      name: name$1\n    };\n    return validate && !validateIconName(result) ? null : result;\n  }\n  const name = colonSeparated[0];\n  const dashSeparated = name.split(\"-\");\n  if (dashSeparated.length > 1) {\n    const result = {\n      provider,\n      prefix: dashSeparated.shift(),\n      name: dashSeparated.join(\"-\")\n    };\n    return validate && !validateIconName(result) ? null : result;\n  }\n  if (allowSimpleName && provider === \"\") {\n    const result = {\n      provider,\n      prefix: \"\",\n      name\n    };\n    return validate && !validateIconName(result, allowSimpleName) ? null : result;\n  }\n  return null;\n};\n/**\n* Check if icon is valid.\n*\n* This function is not part of stringToIcon because validation is not needed for most code.\n*/\nconst validateIconName = (icon, allowSimpleName) => {\n  if (!icon) return false;\n  return !!((allowSimpleName && icon.prefix === \"\" || !!icon.prefix) && !!icon.name);\n};\n\n/**\n* Allow storing icons without provider or prefix, making it possible to store icons like \"home\"\n*/\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n  if (typeof allow === \"boolean\") simpleNames = allow;\n  return simpleNames;\n}\n/**\n* Get icon data\n*\n* Returns:\n* - IconifyIcon on success, object directly from storage so don't modify it\n* - null if icon is marked as missing (returned in `not_found` property from API, so don't bother sending API requests)\n* - undefined if icon is missing in storage\n*/\nfunction getIconData(name) {\n  const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n  if (icon) {\n    const storage = getStorage(icon.provider, icon.prefix);\n    const iconName = icon.name;\n    return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n  }\n}\n/**\n* Add one icon\n*/\nfunction addIcon(name, data) {\n  const icon = stringToIcon(name, true, simpleNames);\n  if (!icon) return false;\n  const storage = getStorage(icon.provider, icon.prefix);\n  if (data) return addIconToStorage(storage, icon.name, data);else {\n    storage.missing.add(icon.name);\n    return true;\n  }\n}\n/**\n* Add icon set\n*/\nfunction addCollection(data, provider) {\n  if (typeof data !== \"object\") return false;\n  if (typeof provider !== \"string\") provider = data.provider || \"\";\n  if (simpleNames && !provider && !data.prefix) {\n    let added = false;\n    if (quicklyValidateIconSet(data)) {\n      data.prefix = \"\";\n      parseIconSet(data, (name, icon) => {\n        if (addIcon(name, icon)) added = true;\n      });\n    }\n    return added;\n  }\n  const prefix = data.prefix;\n  if (!validateIconName({\n    prefix,\n    name: \"a\"\n  })) return false;\n  const storage = getStorage(provider, prefix);\n  return !!addIconSet(storage, data);\n}\n/**\n* Check if icon data is available\n*/\nfunction iconLoaded(name) {\n  return !!getIconData(name);\n}\n/**\n* Get full icon\n*/\nfunction getIcon(name) {\n  const result = getIconData(name);\n  return result ? {\n    ...defaultIconProps,\n    ...result\n  } : result;\n}\n\n/**\n* Default icon customisations values\n*/\nconst defaultIconSizeCustomisations = Object.freeze({\n  width: null,\n  height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n  ...defaultIconSizeCustomisations,\n  ...defaultIconTransformations\n});\n\n/**\n* Regular expressions for calculating dimensions\n*/\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n  if (ratio === 1) return size;\n  precision = precision || 100;\n  if (typeof size === \"number\") return Math.ceil(size * ratio * precision) / precision;\n  if (typeof size !== \"string\") return size;\n  const oldParts = size.split(unitsSplit);\n  if (oldParts === null || !oldParts.length) return size;\n  const newParts = [];\n  let code = oldParts.shift();\n  let isNumber = unitsTest.test(code);\n  while (true) {\n    if (isNumber) {\n      const num = parseFloat(code);\n      if (isNaN(num)) newParts.push(code);else newParts.push(Math.ceil(num * ratio * precision) / precision);\n    } else newParts.push(code);\n    code = oldParts.shift();\n    if (code === void 0) return newParts.join(\"\");\n    isNumber = !isNumber;\n  }\n}\nfunction splitSVGDefs(content, tag = \"defs\") {\n  let defs = \"\";\n  const index = content.indexOf(\"<\" + tag);\n  while (index >= 0) {\n    const start = content.indexOf(\">\", index);\n    const end = content.indexOf(\"</\" + tag);\n    if (start === -1 || end === -1) break;\n    const endEnd = content.indexOf(\">\", end);\n    if (endEnd === -1) break;\n    defs += content.slice(start + 1, end).trim();\n    content = content.slice(0, index).trim() + content.slice(endEnd + 1);\n  }\n  return {\n    defs,\n    content\n  };\n}\n/**\n* Merge defs and content\n*/\nfunction mergeDefsAndContent(defs, content) {\n  return defs ? \"<defs>\" + defs + \"</defs>\" + content : content;\n}\n/**\n* Wrap SVG content, without wrapping definitions\n*/\nfunction wrapSVGContent(body, start, end) {\n  const split = splitSVGDefs(body);\n  return mergeDefsAndContent(split.defs, start + split.content + end);\n}\n\n/**\n* Check if value should be unset. Allows multiple keywords\n*/\nconst isUnsetKeyword = value => value === \"unset\" || value === \"undefined\" || value === \"none\";\n/**\n* Get SVG attributes and content from icon + customisations\n*\n* Does not generate style to make it compatible with frameworks that use objects for style, such as React.\n* Instead, it generates 'inline' value. If true, rendering engine should add verticalAlign: -0.125em to icon.\n*\n* Customisations should be normalised by platform specific parser.\n* Result should be converted to <svg> by platform specific parser.\n* Use replaceIDs to generate unique IDs for body.\n*/\nfunction iconToSVG(icon, customisations) {\n  const fullIcon = {\n    ...defaultIconProps,\n    ...icon\n  };\n  const fullCustomisations = {\n    ...defaultIconCustomisations,\n    ...customisations\n  };\n  const box = {\n    left: fullIcon.left,\n    top: fullIcon.top,\n    width: fullIcon.width,\n    height: fullIcon.height\n  };\n  let body = fullIcon.body;\n  [fullIcon, fullCustomisations].forEach(props => {\n    const transformations = [];\n    const hFlip = props.hFlip;\n    const vFlip = props.vFlip;\n    let rotation = props.rotate;\n    if (hFlip) {\n      if (vFlip) rotation += 2;else {\n        transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n        transformations.push(\"scale(-1 1)\");\n        box.top = box.left = 0;\n      }\n    } else if (vFlip) {\n      transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n      transformations.push(\"scale(1 -1)\");\n      box.top = box.left = 0;\n    }\n    let tempValue;\n    if (rotation < 0) rotation -= Math.floor(rotation / 4) * 4;\n    rotation = rotation % 4;\n    switch (rotation) {\n      case 1:\n        tempValue = box.height / 2 + box.top;\n        transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n        break;\n      case 2:\n        transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n        break;\n      case 3:\n        tempValue = box.width / 2 + box.left;\n        transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n        break;\n    }\n    if (rotation % 2 === 1) {\n      if (box.left !== box.top) {\n        tempValue = box.left;\n        box.left = box.top;\n        box.top = tempValue;\n      }\n      if (box.width !== box.height) {\n        tempValue = box.width;\n        box.width = box.height;\n        box.height = tempValue;\n      }\n    }\n    if (transformations.length) body = wrapSVGContent(body, \"<g transform=\\\"\" + transformations.join(\" \") + \"\\\">\", \"</g>\");\n  });\n  const customisationsWidth = fullCustomisations.width;\n  const customisationsHeight = fullCustomisations.height;\n  const boxWidth = box.width;\n  const boxHeight = box.height;\n  let width;\n  let height;\n  if (customisationsWidth === null) {\n    height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    width = calculateSize(height, boxWidth / boxHeight);\n  } else {\n    width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n  }\n  const attributes = {};\n  const setAttr = (prop, value) => {\n    if (!isUnsetKeyword(value)) attributes[prop] = value.toString();\n  };\n  setAttr(\"width\", width);\n  setAttr(\"height\", height);\n  const viewBox = [box.left, box.top, boxWidth, boxHeight];\n  attributes.viewBox = viewBox.join(\" \");\n  return {\n    attributes,\n    viewBox,\n    body\n  };\n}\n\n/**\n* IDs usage:\n*\n* id=\"{id}\"\n* xlink:href=\"#{id}\"\n* url(#{id})\n*\n* From SVG animations:\n*\n* begin=\"0;{id}.end\"\n* begin=\"{id}.end\"\n* begin=\"{id}.click\"\n*/\n/**\n* Regular expression for finding ids\n*/\nconst regex = /\\sid=\"(\\S+)\"/g;\n/**\n* New random-ish prefix for ids\n*\n* Do not use dash, it cannot be used in SVG 2 animations\n*/\nconst randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\n/**\n* Counter for ids, increasing with every replacement\n*/\nlet counter = 0;\n/**\n* Replace IDs in SVG output with unique IDs\n*/\nfunction replaceIDs(body, prefix = randomPrefix) {\n  const ids = [];\n  let match;\n  while (match = regex.exec(body)) ids.push(match[1]);\n  if (!ids.length) return body;\n  const suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n  ids.forEach(id => {\n    const newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n    const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    body = body.replace(new RegExp(\"([#;\\\"])(\" + escapedID + \")([\\\")]|\\\\.[a-z])\", \"g\"), \"$1\" + newID + suffix + \"$3\");\n  });\n  body = body.replace(new RegExp(suffix, \"g\"), \"\");\n  return body;\n}\n\n/**\n* Local storate types and entries\n*/\nconst storage = Object.create(null);\n/**\n* Set API module\n*/\nfunction setAPIModule(provider, item) {\n  storage[provider] = item;\n}\n/**\n* Get API module\n*/\nfunction getAPIModule(provider) {\n  return storage[provider] || storage[\"\"];\n}\n\n/**\n* Create full API configuration from partial data\n*/\nfunction createAPIConfig(source) {\n  let resources;\n  if (typeof source.resources === \"string\") resources = [source.resources];else {\n    resources = source.resources;\n    if (!(resources instanceof Array) || !resources.length) return null;\n  }\n  const result = {\n    resources,\n    path: source.path || \"/\",\n    maxURL: source.maxURL || 500,\n    rotate: source.rotate || 750,\n    timeout: source.timeout || 5e3,\n    random: source.random === true,\n    index: source.index || 0,\n    dataAfterTimeout: source.dataAfterTimeout !== false\n  };\n  return result;\n}\n/**\n* Local storage\n*/\nconst configStorage = Object.create(null);\n/**\n* Redundancy for API servers.\n*\n* API should have very high uptime because of implemented redundancy at server level, but\n* sometimes bad things happen. On internet 100% uptime is not possible.\n*\n* There could be routing problems. Server might go down for whatever reason, but it takes\n* few minutes to detect that downtime, so during those few minutes API might not be accessible.\n*\n* This script has some redundancy to mitigate possible network issues.\n*\n* If one host cannot be reached in 'rotate' (750 by default) ms, script will try to retrieve\n* data from different host. Hosts have different configurations, pointing to different\n* API servers hosted at different providers.\n*/\nconst fallBackAPISources = [\"https://api.simplesvg.com\", \"https://api.unisvg.com\"];\nconst fallBackAPI = [];\nwhile (fallBackAPISources.length > 0) if (fallBackAPISources.length === 1) fallBackAPI.push(fallBackAPISources.shift());else if (Math.random() > .5) fallBackAPI.push(fallBackAPISources.shift());else fallBackAPI.push(fallBackAPISources.pop());\nconfigStorage[\"\"] = createAPIConfig({\n  resources: [\"https://api.iconify.design\"].concat(fallBackAPI)\n});\n/**\n* Add custom config for provider\n*/\nfunction addAPIProvider(provider, customConfig) {\n  const config = createAPIConfig(customConfig);\n  if (config === null) return false;\n  configStorage[provider] = config;\n  return true;\n}\n/**\n* Get API configuration\n*/\nfunction getAPIConfig(provider) {\n  return configStorage[provider];\n}\n/**\n* List API providers\n*/\nfunction listAPIProviders() {\n  return Object.keys(configStorage);\n}\nconst detectFetch = () => {\n  let callback;\n  try {\n    callback = fetch;\n    if (typeof callback === \"function\") return callback;\n  } catch (err) {}\n};\n/**\n* Fetch function\n*/\nlet fetchModule = detectFetch();\n/**\n* Set custom fetch() function\n*/\nfunction setFetch(fetch$1) {\n  fetchModule = fetch$1;\n}\n/**\n* Get fetch() function. Used by Icon Finder Core\n*/\nfunction getFetch() {\n  return fetchModule;\n}\n/**\n* Calculate maximum icons list length for prefix\n*/\nfunction calculateMaxLength(provider, prefix) {\n  const config = getAPIConfig(provider);\n  if (!config) return 0;\n  let result;\n  if (!config.maxURL) result = 0;else {\n    let maxHostLength = 0;\n    config.resources.forEach(item => {\n      const host = item;\n      maxHostLength = Math.max(maxHostLength, host.length);\n    });\n    const url = prefix + \".json?icons=\";\n    result = config.maxURL - maxHostLength - config.path.length - url.length;\n  }\n  return result;\n}\n/**\n* Should query be aborted, based on last HTTP status\n*/\nfunction shouldAbort(status) {\n  return status === 404;\n}\n/**\n* Prepare params\n*/\nconst prepare = (provider, prefix, icons) => {\n  const results = [];\n  const maxLength = calculateMaxLength(provider, prefix);\n  const type = \"icons\";\n  let item = {\n    type,\n    provider,\n    prefix,\n    icons: []\n  };\n  let length = 0;\n  icons.forEach((name, index) => {\n    length += name.length + 1;\n    if (length >= maxLength && index > 0) {\n      results.push(item);\n      item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n      };\n      length = name.length;\n    }\n    item.icons.push(name);\n  });\n  results.push(item);\n  return results;\n};\n/**\n* Get path\n*/\nfunction getPath(provider) {\n  if (typeof provider === \"string\") {\n    const config = getAPIConfig(provider);\n    if (config) return config.path;\n  }\n  return \"/\";\n}\n/**\n* Load icons\n*/\nconst send = (host, params, callback) => {\n  if (!fetchModule) {\n    callback(\"abort\", 424);\n    return;\n  }\n  let path = getPath(params.provider);\n  switch (params.type) {\n    case \"icons\":\n      {\n        const prefix = params.prefix;\n        const icons = params.icons;\n        const iconsList = icons.join(\",\");\n        const urlParams = new URLSearchParams({\n          icons: iconsList\n        });\n        path += prefix + \".json?\" + urlParams.toString();\n        break;\n      }\n    case \"custom\":\n      {\n        const uri = params.uri;\n        path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n        break;\n      }\n    default:\n      callback(\"abort\", 400);\n      return;\n  }\n  let defaultError = 503;\n  fetchModule(host + path).then(response => {\n    const status = response.status;\n    if (status !== 200) {\n      setTimeout(() => {\n        callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n      });\n      return;\n    }\n    defaultError = 501;\n    return response.json();\n  }).then(data => {\n    if (typeof data !== \"object\" || data === null) {\n      setTimeout(() => {\n        if (data === 404) callback(\"abort\", data);else callback(\"next\", defaultError);\n      });\n      return;\n    }\n    setTimeout(() => {\n      callback(\"success\", data);\n    });\n  }).catch(() => {\n    callback(\"next\", defaultError);\n  });\n};\n/**\n* Export module\n*/\nconst fetchAPIModule = {\n  prepare,\n  send\n};\n\n/**\n* Remove callback\n*/\nfunction removeCallback(storages, id) {\n  storages.forEach(storage => {\n    const items = storage.loaderCallbacks;\n    if (items) storage.loaderCallbacks = items.filter(row => row.id !== id);\n  });\n}\n/**\n* Update all callbacks for provider and prefix\n*/\nfunction updateCallbacks(storage) {\n  if (!storage.pendingCallbacksFlag) {\n    storage.pendingCallbacksFlag = true;\n    setTimeout(() => {\n      storage.pendingCallbacksFlag = false;\n      const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n      if (!items.length) return;\n      let hasPending = false;\n      const provider = storage.provider;\n      const prefix = storage.prefix;\n      items.forEach(item => {\n        const icons = item.icons;\n        const oldLength = icons.pending.length;\n        icons.pending = icons.pending.filter(icon => {\n          if (icon.prefix !== prefix) return true;\n          const name = icon.name;\n          if (storage.icons[name]) icons.loaded.push({\n            provider,\n            prefix,\n            name\n          });else if (storage.missing.has(name)) icons.missing.push({\n            provider,\n            prefix,\n            name\n          });else {\n            hasPending = true;\n            return true;\n          }\n          return false;\n        });\n        if (icons.pending.length !== oldLength) {\n          if (!hasPending) removeCallback([storage], item.id);\n          item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n        }\n      });\n    });\n  }\n}\n/**\n* Unique id counter for callbacks\n*/\nlet idCounter = 0;\n/**\n* Add callback\n*/\nfunction storeCallback(callback, icons, pendingSources) {\n  const id = idCounter++;\n  const abort = removeCallback.bind(null, pendingSources, id);\n  if (!icons.pending.length) return abort;\n  const item = {\n    id,\n    icons,\n    callback,\n    abort\n  };\n  pendingSources.forEach(storage => {\n    (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n  });\n  return abort;\n}\n\n/**\n* Check if icons have been loaded\n*/\nfunction sortIcons(icons) {\n  const result = {\n    loaded: [],\n    missing: [],\n    pending: []\n  };\n  const storage = Object.create(null);\n  icons.sort((a, b) => {\n    if (a.provider !== b.provider) return a.provider.localeCompare(b.provider);\n    if (a.prefix !== b.prefix) return a.prefix.localeCompare(b.prefix);\n    return a.name.localeCompare(b.name);\n  });\n  let lastIcon = {\n    provider: \"\",\n    prefix: \"\",\n    name: \"\"\n  };\n  icons.forEach(icon => {\n    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) return;\n    lastIcon = icon;\n    const provider = icon.provider;\n    const prefix = icon.prefix;\n    const name = icon.name;\n    const providerStorage = storage[provider] || (storage[provider] = Object.create(null));\n    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n    let list;\n    if (name in localStorage.icons) list = result.loaded;else if (prefix === \"\" || localStorage.missing.has(name)) list = result.missing;else list = result.pending;\n    const item = {\n      provider,\n      prefix,\n      name\n    };\n    list.push(item);\n  });\n  return result;\n}\n\n/**\n* Convert icons list from string/icon mix to icons and validate them\n*/\nfunction listToIcons(list, validate = true, simpleNames = false) {\n  const result = [];\n  list.forEach(item => {\n    const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n    if (icon) result.push(icon);\n  });\n  return result;\n}\n\n/**\n* Default RedundancyConfig for API calls\n*/\nconst defaultConfig = {\n  resources: [],\n  index: 0,\n  timeout: 2e3,\n  rotate: 750,\n  random: false,\n  dataAfterTimeout: false\n};\n\n/**\n* Send query\n*/\nfunction sendQuery(config, payload, query, done) {\n  const resourcesCount = config.resources.length;\n  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n  let resources;\n  if (config.random) {\n    let list = config.resources.slice(0);\n    resources = [];\n    while (list.length > 1) {\n      const nextIndex = Math.floor(Math.random() * list.length);\n      resources.push(list[nextIndex]);\n      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n    }\n    resources = resources.concat(list);\n  } else resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n  const startTime = Date.now();\n  let status = \"pending\";\n  let queriesSent = 0;\n  let lastError;\n  let timer = null;\n  let queue = [];\n  let doneCallbacks = [];\n  if (typeof done === \"function\") doneCallbacks.push(done);\n  /**\n  * Reset timer\n  */\n  function resetTimer() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  /**\n  * Abort everything\n  */\n  function abort() {\n    if (status === \"pending\") status = \"aborted\";\n    resetTimer();\n    queue.forEach(item => {\n      if (item.status === \"pending\") item.status = \"aborted\";\n    });\n    queue = [];\n  }\n  /**\n  * Add / replace callback to call when execution is complete.\n  * This can be used to abort pending query implementations when query is complete or aborted.\n  */\n  function subscribe(callback, overwrite) {\n    if (overwrite) doneCallbacks = [];\n    if (typeof callback === \"function\") doneCallbacks.push(callback);\n  }\n  /**\n  * Get query status\n  */\n  function getQueryStatus() {\n    return {\n      startTime,\n      payload,\n      status,\n      queriesSent,\n      queriesPending: queue.length,\n      subscribe,\n      abort\n    };\n  }\n  /**\n  * Fail query\n  */\n  function failQuery() {\n    status = \"failed\";\n    doneCallbacks.forEach(callback => {\n      callback(void 0, lastError);\n    });\n  }\n  /**\n  * Clear queue\n  */\n  function clearQueue() {\n    queue.forEach(item => {\n      if (item.status === \"pending\") item.status = \"aborted\";\n    });\n    queue = [];\n  }\n  /**\n  * Got response from module\n  */\n  function moduleResponse(item, response, data) {\n    const isError = response !== \"success\";\n    queue = queue.filter(queued => queued !== item);\n    switch (status) {\n      case \"pending\":\n        break;\n      case \"failed\":\n        if (isError || !config.dataAfterTimeout) return;\n        break;\n      default:\n        return;\n    }\n    if (response === \"abort\") {\n      lastError = data;\n      failQuery();\n      return;\n    }\n    if (isError) {\n      lastError = data;\n      if (!queue.length) if (!resources.length) failQuery();else execNext();\n      return;\n    }\n    resetTimer();\n    clearQueue();\n    if (!config.random) {\n      const index = config.resources.indexOf(item.resource);\n      if (index !== -1 && index !== config.index) config.index = index;\n    }\n    status = \"completed\";\n    doneCallbacks.forEach(callback => {\n      callback(data);\n    });\n  }\n  /**\n  * Execute next query\n  */\n  function execNext() {\n    if (status !== \"pending\") return;\n    resetTimer();\n    const resource = resources.shift();\n    if (resource === void 0) {\n      if (queue.length) {\n        timer = setTimeout(() => {\n          resetTimer();\n          if (status === \"pending\") {\n            clearQueue();\n            failQuery();\n          }\n        }, config.timeout);\n        return;\n      }\n      failQuery();\n      return;\n    }\n    const item = {\n      status: \"pending\",\n      resource,\n      callback: (status$1, data) => {\n        moduleResponse(item, status$1, data);\n      }\n    };\n    queue.push(item);\n    queriesSent++;\n    timer = setTimeout(execNext, config.rotate);\n    query(resource, payload, item.callback);\n  }\n  setTimeout(execNext);\n  return getQueryStatus;\n}\n\n/**\n* Redundancy instance\n*/\nfunction initRedundancy(cfg) {\n  const config = {\n    ...defaultConfig,\n    ...cfg\n  };\n  let queries = [];\n  /**\n  * Remove aborted and completed queries\n  */\n  function cleanup() {\n    queries = queries.filter(item => item().status === \"pending\");\n  }\n  /**\n  * Send query\n  */\n  function query(payload, queryCallback, doneCallback) {\n    const query$1 = sendQuery(config, payload, queryCallback, (data, error) => {\n      cleanup();\n      if (doneCallback) doneCallback(data, error);\n    });\n    queries.push(query$1);\n    return query$1;\n  }\n  /**\n  * Find instance\n  */\n  function find(callback) {\n    return queries.find(value => {\n      return callback(value);\n    }) || null;\n  }\n  const instance = {\n    query,\n    find,\n    setIndex: index => {\n      config.index = index;\n    },\n    getIndex: () => config.index,\n    cleanup\n  };\n  return instance;\n}\nfunction emptyCallback$1() {}\nconst redundancyCache = Object.create(null);\n/**\n* Get Redundancy instance for provider\n*/\nfunction getRedundancyCache(provider) {\n  if (!redundancyCache[provider]) {\n    const config = getAPIConfig(provider);\n    if (!config) return;\n    const redundancy = initRedundancy(config);\n    const cachedReundancy = {\n      config,\n      redundancy\n    };\n    redundancyCache[provider] = cachedReundancy;\n  }\n  return redundancyCache[provider];\n}\n/**\n* Send API query\n*/\nfunction sendAPIQuery(target, query, callback) {\n  let redundancy;\n  let send;\n  if (typeof target === \"string\") {\n    const api = getAPIModule(target);\n    if (!api) {\n      callback(void 0, 424);\n      return emptyCallback$1;\n    }\n    send = api.send;\n    const cached = getRedundancyCache(target);\n    if (cached) redundancy = cached.redundancy;\n  } else {\n    const config = createAPIConfig(target);\n    if (config) {\n      redundancy = initRedundancy(config);\n      const moduleKey = target.resources ? target.resources[0] : \"\";\n      const api = getAPIModule(moduleKey);\n      if (api) send = api.send;\n    }\n  }\n  if (!redundancy || !send) {\n    callback(void 0, 424);\n    return emptyCallback$1;\n  }\n  return redundancy.query(query, send, callback)().abort;\n}\nfunction emptyCallback() {}\n/**\n* Function called when new icons have been loaded\n*/\nfunction loadedNewIcons(storage) {\n  if (!storage.iconsLoaderFlag) {\n    storage.iconsLoaderFlag = true;\n    setTimeout(() => {\n      storage.iconsLoaderFlag = false;\n      updateCallbacks(storage);\n    });\n  }\n}\n/**\n* Check icon names for API\n*/\nfunction checkIconNamesForAPI(icons) {\n  const valid = [];\n  const invalid = [];\n  icons.forEach(name => {\n    (name.match(matchIconName) ? valid : invalid).push(name);\n  });\n  return {\n    valid,\n    invalid\n  };\n}\n/**\n* Parse loader response\n*/\nfunction parseLoaderResponse(storage, icons, data) {\n  function checkMissing() {\n    const pending = storage.pendingIcons;\n    icons.forEach(name => {\n      if (pending) pending.delete(name);\n      if (!storage.icons[name]) storage.missing.add(name);\n    });\n  }\n  if (data && typeof data === \"object\") try {\n    const parsed = addIconSet(storage, data);\n    if (!parsed.length) {\n      checkMissing();\n      return;\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  checkMissing();\n  loadedNewIcons(storage);\n}\n/**\n* Handle response that can be async\n*/\nfunction parsePossiblyAsyncResponse(response, callback) {\n  if (response instanceof Promise) response.then(data => {\n    callback(data);\n  }).catch(() => {\n    callback(null);\n  });else callback(response);\n}\n/**\n* Load icons\n*/\nfunction loadNewIcons(storage, icons) {\n  if (!storage.iconsToLoad) storage.iconsToLoad = icons;else storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n  if (!storage.iconsQueueFlag) {\n    storage.iconsQueueFlag = true;\n    setTimeout(() => {\n      storage.iconsQueueFlag = false;\n      const {\n        provider,\n        prefix\n      } = storage;\n      const icons$1 = storage.iconsToLoad;\n      delete storage.iconsToLoad;\n      if (!icons$1 || !icons$1.length) return;\n      const customIconLoader = storage.loadIcon;\n      if (storage.loadIcons && (icons$1.length > 1 || !customIconLoader)) {\n        parsePossiblyAsyncResponse(storage.loadIcons(icons$1, prefix, provider), data => {\n          parseLoaderResponse(storage, icons$1, data);\n        });\n        return;\n      }\n      if (customIconLoader) {\n        icons$1.forEach(name => {\n          const response = customIconLoader(name, prefix, provider);\n          parsePossiblyAsyncResponse(response, data => {\n            const iconSet = data ? {\n              prefix,\n              icons: {\n                [name]: data\n              }\n            } : null;\n            parseLoaderResponse(storage, [name], iconSet);\n          });\n        });\n        return;\n      }\n      const {\n        valid,\n        invalid\n      } = checkIconNamesForAPI(icons$1);\n      if (invalid.length) parseLoaderResponse(storage, invalid, null);\n      if (!valid.length) return;\n      const api = prefix.match(matchIconName) ? getAPIModule(provider) : null;\n      if (!api) {\n        parseLoaderResponse(storage, valid, null);\n        return;\n      }\n      const params = api.prepare(provider, prefix, valid);\n      params.forEach(item => {\n        sendAPIQuery(provider, item, data => {\n          parseLoaderResponse(storage, item.icons, data);\n        });\n      });\n    });\n  }\n}\n/**\n* Load icons\n*/\nconst loadIcons = (icons, callback) => {\n  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n  const sortedIcons = sortIcons(cleanedIcons);\n  if (!sortedIcons.pending.length) {\n    let callCallback = true;\n    if (callback) setTimeout(() => {\n      if (callCallback) callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n    });\n    return () => {\n      callCallback = false;\n    };\n  }\n  const newIcons = Object.create(null);\n  const sources = [];\n  let lastProvider, lastPrefix;\n  sortedIcons.pending.forEach(icon => {\n    const {\n      provider,\n      prefix\n    } = icon;\n    if (prefix === lastPrefix && provider === lastProvider) return;\n    lastProvider = provider;\n    lastPrefix = prefix;\n    sources.push(getStorage(provider, prefix));\n    const providerNewIcons = newIcons[provider] || (newIcons[provider] = Object.create(null));\n    if (!providerNewIcons[prefix]) providerNewIcons[prefix] = [];\n  });\n  sortedIcons.pending.forEach(icon => {\n    const {\n      provider,\n      prefix,\n      name\n    } = icon;\n    const storage = getStorage(provider, prefix);\n    const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */new Set());\n    if (!pendingQueue.has(name)) {\n      pendingQueue.add(name);\n      newIcons[provider][prefix].push(name);\n    }\n  });\n  sources.forEach(storage => {\n    const list = newIcons[storage.provider][storage.prefix];\n    if (list.length) loadNewIcons(storage, list);\n  });\n  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\n/**\n* Load one icon using Promise\n*/\nconst loadIcon = icon => {\n  return new Promise((fulfill, reject) => {\n    const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n    if (!iconObj) {\n      reject(icon);\n      return;\n    }\n    loadIcons([iconObj || icon], loaded => {\n      if (loaded.length && iconObj) {\n        const data = getIconData(iconObj);\n        if (data) {\n          fulfill({\n            ...defaultIconProps,\n            ...data\n          });\n          return;\n        }\n      }\n      reject(icon);\n    });\n  });\n};\n\n/**\n* Set custom loader for multiple icons\n*/\nfunction setCustomIconsLoader(loader, prefix, provider) {\n  getStorage(provider || \"\", prefix).loadIcons = loader;\n}\n/**\n* Set custom loader for one icon\n*/\nfunction setCustomIconLoader(loader, prefix, provider) {\n  getStorage(provider || \"\", prefix).loadIcon = loader;\n}\n\n/**\n* Convert IconifyIconCustomisations to FullIconCustomisations, checking value types\n*/\nfunction mergeCustomisations(defaults, item) {\n  const result = {\n    ...defaults\n  };\n  for (const key in item) {\n    const value = item[key];\n    const valueType = typeof value;\n    if (key in defaultIconSizeCustomisations) {\n      if (value === null || value && (valueType === \"string\" || valueType === \"number\")) result[key] = value;\n    } else if (valueType === typeof result[key]) result[key] = key === \"rotate\" ? value % 4 : value;\n  }\n  return result;\n}\nconst separator = /[\\s,]+/;\n/**\n* Apply \"flip\" string to icon customisations\n*/\nfunction flipFromString(custom, flip) {\n  flip.split(separator).forEach(str => {\n    const value = str.trim();\n    switch (value) {\n      case \"horizontal\":\n        custom.hFlip = true;\n        break;\n      case \"vertical\":\n        custom.vFlip = true;\n        break;\n    }\n  });\n}\n\n/**\n* Get rotation value\n*/\nfunction rotateFromString(value, defaultValue = 0) {\n  const units = value.replace(/^-?[0-9.]*/, \"\");\n  function cleanup(value$1) {\n    while (value$1 < 0) value$1 += 4;\n    return value$1 % 4;\n  }\n  if (units === \"\") {\n    const num = parseInt(value);\n    return isNaN(num) ? 0 : cleanup(num);\n  } else if (units !== value) {\n    let split = 0;\n    switch (units) {\n      case \"%\":\n        split = 25;\n        break;\n      case \"deg\":\n        split = 90;\n    }\n    if (split) {\n      let num = parseFloat(value.slice(0, value.length - units.length));\n      if (isNaN(num)) return 0;\n      num = num / split;\n      return num % 1 === 0 ? cleanup(num) : 0;\n    }\n  }\n  return defaultValue;\n}\n\n/**\n* Generate <svg>\n*/\nfunction iconToHTML(body, attributes) {\n  let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : \" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\";\n  for (const attr in attributes) renderAttribsHTML += \" \" + attr + \"=\\\"\" + attributes[attr] + \"\\\"\";\n  return \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\" + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\n\n/**\n* Encode SVG for use in url()\n*\n* Short alternative to encodeURIComponent() that encodes only stuff used in SVG, generating\n* smaller code.\n*/\nfunction encodeSVGforURL(svg) {\n  return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\n/**\n* Generate data: URL from SVG\n*/\nfunction svgToData(svg) {\n  return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\n/**\n* Generate url() from SVG\n*/\nfunction svgToURL(svg) {\n  return \"url(\\\"\" + svgToData(svg) + \"\\\")\";\n}\nlet policy;\n/**\n* Attempt to create policy\n*/\nfunction createPolicy() {\n  try {\n    policy = window.trustedTypes.createPolicy(\"iconify\", {\n      createHTML: s => s\n    });\n  } catch (err) {\n    policy = null;\n  }\n}\n/**\n* Clean up value for innerHTML assignment\n*\n* This code doesn't actually clean up anything.\n* It is intended be used with Iconify icon data, which has already been validated\n*/\nfunction cleanUpInnerHTML(html) {\n  if (policy === void 0) createPolicy();\n  return policy ? policy.createHTML(html) : html;\n}\nconst defaultExtendedIconCustomisations = {\n  ...defaultIconCustomisations,\n  inline: false\n};\n\n/**\n * Default SVG attributes\n */\nconst svgDefaults = {\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlnsXlink': 'http://www.w3.org/1999/xlink',\n  'aria-hidden': true,\n  'role': 'img'\n};\n/**\n * Style modes\n */\nconst commonProps = {\n  display: 'inline-block'\n};\nconst monotoneProps = {\n  backgroundColor: 'currentColor'\n};\nconst coloredProps = {\n  backgroundColor: 'transparent'\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n  Image: 'var(--svg)',\n  Repeat: 'no-repeat',\n  Size: '100% 100%'\n};\nconst propsToAddTo = {\n  WebkitMask: monotoneProps,\n  mask: monotoneProps,\n  background: coloredProps\n};\nfor (const prefix in propsToAddTo) {\n  const list = propsToAddTo[prefix];\n  for (const prop in propsToAdd) {\n    list[prefix + prop] = propsToAdd[prop];\n  }\n}\n/**\n * Default values for customisations for inline icon\n */\nconst inlineDefaults = {\n  ...defaultExtendedIconCustomisations,\n  inline: true\n};\n/**\n * Fix size: add 'px' to numbers\n */\nfunction fixSize(value) {\n  return value + (value.match(/^[-0-9.]+$/) ? 'px' : '');\n}\n/**\n * Render icon\n */\nconst render = (\n// Icon must be validated before calling this function\nicon,\n// Partial properties\nprops,\n// Icon name\nname) => {\n  // Get default properties\n  const defaultProps = props.inline ? inlineDefaults : defaultExtendedIconCustomisations;\n  // Get all customisations\n  const customisations = mergeCustomisations(defaultProps, props);\n  // Check mode\n  const mode = props.mode || 'svg';\n  // Create style\n  const style = {};\n  const customStyle = props.style || {};\n  // Create SVG component properties\n  const componentProps = {\n    ...(mode === 'svg' ? svgDefaults : {})\n  };\n  if (name) {\n    const iconName = stringToIcon(name, false, true);\n    if (iconName) {\n      const classNames = ['iconify'];\n      const props = ['provider', 'prefix'];\n      for (const prop of props) {\n        if (iconName[prop]) {\n          classNames.push('iconify--' + iconName[prop]);\n        }\n      }\n      componentProps.className = classNames.join(' ');\n    }\n  }\n  // Get element properties\n  for (let key in props) {\n    const value = props[key];\n    if (value === void 0) {\n      continue;\n    }\n    switch (key) {\n      // Properties to ignore\n      case 'icon':\n      case 'style':\n      case 'children':\n      case 'onLoad':\n      case 'mode':\n      case 'ssr':\n      case 'fallback':\n        break;\n      // Forward ref\n      case '_ref':\n        componentProps.ref = value;\n        break;\n      // Merge class names\n      case 'className':\n        componentProps[key] = (componentProps[key] ? componentProps[key] + ' ' : '') + value;\n        break;\n      // Boolean attributes\n      case 'inline':\n      case 'hFlip':\n      case 'vFlip':\n        customisations[key] = value === true || value === 'true' || value === 1;\n        break;\n      // Flip as string: 'horizontal,vertical'\n      case 'flip':\n        if (typeof value === 'string') {\n          flipFromString(customisations, value);\n        }\n        break;\n      // Color: copy to style\n      case 'color':\n        style.color = value;\n        break;\n      // Rotation as string\n      case 'rotate':\n        if (typeof value === 'string') {\n          customisations[key] = rotateFromString(value);\n        } else if (typeof value === 'number') {\n          customisations[key] = value;\n        }\n        break;\n      // Remove aria-hidden\n      case 'ariaHidden':\n      case 'aria-hidden':\n        if (value !== true && value !== 'true') {\n          delete componentProps['aria-hidden'];\n        }\n        break;\n      // Copy missing property if it does not exist in customisations\n      default:\n        if (defaultProps[key] === void 0) {\n          componentProps[key] = value;\n        }\n    }\n  }\n  // Generate icon\n  const item = iconToSVG(icon, customisations);\n  const renderAttribs = item.attributes;\n  // Inline display\n  if (customisations.inline) {\n    style.verticalAlign = '-0.125em';\n  }\n  if (mode === 'svg') {\n    // Add style\n    componentProps.style = {\n      ...style,\n      ...customStyle\n    };\n    // Add icon stuff\n    Object.assign(componentProps, renderAttribs);\n    // Counter for ids based on \"id\" property to render icons consistently on server and client\n    let localCounter = 0;\n    let id = props.id;\n    if (typeof id === 'string') {\n      // Convert '-' to '_' to avoid errors in animations\n      id = id.replace(/-/g, '_');\n    }\n    // Add icon stuff\n    componentProps.dangerouslySetInnerHTML = {\n      __html: cleanUpInnerHTML(replaceIDs(item.body, id ? () => id + 'ID' + localCounter++ : 'iconifyReact'))\n    };\n    return createElement('svg', componentProps);\n  }\n  // Render <span> with style\n  const {\n    body,\n    width,\n    height\n  } = icon;\n  const useMask = mode === 'mask' || (mode === 'bg' ? false : body.indexOf('currentColor') !== -1);\n  // Generate SVG\n  const html = iconToHTML(body, {\n    ...renderAttribs,\n    width: width + '',\n    height: height + ''\n  });\n  // Generate style\n  componentProps.style = {\n    ...style,\n    '--svg': svgToURL(html),\n    'width': fixSize(renderAttribs.width),\n    'height': fixSize(renderAttribs.height),\n    ...commonProps,\n    ...(useMask ? monotoneProps : coloredProps),\n    ...customStyle\n  };\n  return createElement('span', componentProps);\n};\n\n/**\n * Initialise stuff\n */\n// Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule('', fetchAPIModule);\n/**\n * Browser stuff\n */\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\n  const _window = window;\n  // Load icons from global \"IconifyPreload\"\n  if (_window.IconifyPreload !== void 0) {\n    const preload = _window.IconifyPreload;\n    const err = 'Invalid IconifyPreload syntax.';\n    if (typeof preload === 'object' && preload !== null) {\n      (preload instanceof Array ? preload : [preload]).forEach(item => {\n        try {\n          if (\n          // Check if item is an object and not null/array\n          typeof item !== 'object' || item === null || item instanceof Array ||\n          // Check for 'icons' and 'prefix'\n          typeof item.icons !== 'object' || typeof item.prefix !== 'string' ||\n          // Add icon set\n          !addCollection(item)) {\n            console.error(err);\n          }\n        } catch (e) {\n          console.error(err);\n        }\n      });\n    }\n  }\n  // Set API from global \"IconifyProviders\"\n  if (_window.IconifyProviders !== void 0) {\n    const providers = _window.IconifyProviders;\n    if (typeof providers === 'object' && providers !== null) {\n      for (let key in providers) {\n        const err = 'IconifyProviders[' + key + '] is invalid.';\n        try {\n          const value = providers[key];\n          if (typeof value !== 'object' || !value || value.resources === void 0) {\n            continue;\n          }\n          if (!addAPIProvider(key, value)) {\n            console.error(err);\n          }\n        } catch (e) {\n          console.error(err);\n        }\n      }\n    }\n  }\n}\nfunction IconComponent(props) {\n  const [mounted, setMounted] = useState(!!props.ssr);\n  const [abort, setAbort] = useState({});\n  // Get initial state\n  function getInitialState(mounted) {\n    if (mounted) {\n      const name = props.icon;\n      if (typeof name === 'object') {\n        // Icon as object\n        return {\n          name: '',\n          data: name\n        };\n      }\n      const data = getIconData(name);\n      if (data) {\n        return {\n          name,\n          data\n        };\n      }\n    }\n    return {\n      name: ''\n    };\n  }\n  const [state, setState] = useState(getInitialState(!!props.ssr));\n  // Cancel loading\n  function cleanup() {\n    const callback = abort.callback;\n    if (callback) {\n      callback();\n      setAbort({});\n    }\n  }\n  // Change state if it is different\n  function changeState(newState) {\n    if (JSON.stringify(state) !== JSON.stringify(newState)) {\n      cleanup();\n      setState(newState);\n      return true;\n    }\n  }\n  // Update state\n  function updateState() {\n    var _a;\n    const name = props.icon;\n    if (typeof name === 'object') {\n      // Icon as object\n      changeState({\n        name: '',\n        data: name\n      });\n      return;\n    }\n    // New icon or got icon data\n    const data = getIconData(name);\n    if (changeState({\n      name,\n      data\n    })) {\n      if (data === undefined) {\n        // Load icon, update state when done\n        const callback = loadIcons([name], updateState);\n        setAbort({\n          callback\n        });\n      } else if (data) {\n        // Icon data is available: trigger onLoad callback if present\n        (_a = props.onLoad) === null || _a === void 0 ? void 0 : _a.call(props, name);\n      }\n    }\n  }\n  // Mounted state, cleanup for loader\n  useEffect(() => {\n    setMounted(true);\n    return cleanup;\n  }, []);\n  // Icon changed or component mounted\n  useEffect(() => {\n    if (mounted) {\n      updateState();\n    }\n  }, [props.icon, mounted]);\n  // Render icon\n  const {\n    name,\n    data\n  } = state;\n  if (!data) {\n    return props.children ? props.children : props.fallback ? props.fallback : createElement('span', {});\n  }\n  return render({\n    ...defaultIconProps,\n    ...data\n  }, props, name);\n}\n/**\n * Block icon\n *\n * @param props - Component properties\n */\nconst Icon = forwardRef((props, ref) => IconComponent({\n  ...props,\n  _ref: ref\n}));\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */\nconst InlineIcon = forwardRef((props, ref) => IconComponent({\n  inline: true,\n  ...props,\n  _ref: ref\n}));\n/**\n * Internal API\n */\nconst _api = {\n  getAPIConfig,\n  setAPIModule,\n  sendAPIQuery,\n  setFetch,\n  getFetch,\n  listAPIProviders\n};\nexport { Icon, InlineIcon, _api, addAPIProvider, addCollection, addIcon, iconToSVG as buildIcon, calculateSize, getIcon, iconLoaded, listIcons, loadIcon, loadIcons, replaceIDs, setCustomIconLoader, setCustomIconsLoader };","map":{"version":3,"names":["createElement","forwardRef","useState","useEffect","getIconsTree","data","names","icons","aliases","Object","create","resolved","resolve","name","parent","value","concat","keys","forEach","defaultIconDimensions","freeze","left","top","width","height","defaultIconTransformations","rotate","vFlip","hFlip","defaultIconProps","defaultExtendedIconProps","body","hidden","mergeIconTransformations","obj1","obj2","result","mergeIconData","child","key","internalGetIconData","tree","currentProps","parse","name$1","parseIconSet","callback","not_found","Array","push","item","optionalPropertyDefaults","provider","checkOptionalProps","defaults","prop","quicklyValidateIconSet","obj","prefix","icon","dataStorage","newStorage","missing","Set","getStorage","providerStorage","addIconSet","storage","add","addIconToStorage","err","listIcons","allIcons","providers","provider$1","prefixes","prefix$1","map","matchIconName","stringToIcon","validate","allowSimpleName","colonSeparated","split","slice","length","shift","pop","validateIconName","dashSeparated","join","simpleNames","allowSimpleNames","allow","getIconData","iconName","has","addIcon","addCollection","added","iconLoaded","getIcon","defaultIconSizeCustomisations","defaultIconCustomisations","unitsSplit","unitsTest","calculateSize","size","ratio","precision","Math","ceil","oldParts","newParts","code","isNumber","test","num","parseFloat","isNaN","splitSVGDefs","content","tag","defs","index","indexOf","start","end","endEnd","trim","mergeDefsAndContent","wrapSVGContent","isUnsetKeyword","iconToSVG","customisations","fullIcon","fullCustomisations","box","props","transformations","rotation","toString","tempValue","floor","unshift","customisationsWidth","customisationsHeight","boxWidth","boxHeight","attributes","setAttr","viewBox","regex","randomPrefix","Date","now","random","counter","replaceIDs","ids","match","exec","suffix","id","newID","escapedID","replace","RegExp","setAPIModule","getAPIModule","createAPIConfig","source","resources","path","maxURL","timeout","dataAfterTimeout","configStorage","fallBackAPISources","fallBackAPI","addAPIProvider","customConfig","config","getAPIConfig","listAPIProviders","detectFetch","fetch","fetchModule","setFetch","fetch$1","getFetch","calculateMaxLength","maxHostLength","host","max","url","shouldAbort","status","prepare","results","maxLength","type","getPath","send","params","iconsList","urlParams","URLSearchParams","uri","defaultError","then","response","setTimeout","json","catch","fetchAPIModule","removeCallback","storages","items","loaderCallbacks","filter","row","updateCallbacks","pendingCallbacksFlag","hasPending","oldLength","pending","loaded","abort","idCounter","storeCallback","pendingSources","bind","sortIcons","sort","a","b","localeCompare","lastIcon","localStorage","list","listToIcons","defaultConfig","sendQuery","payload","query","done","resourcesCount","startIndex","nextIndex","startTime","queriesSent","lastError","timer","queue","doneCallbacks","resetTimer","clearTimeout","subscribe","overwrite","getQueryStatus","queriesPending","failQuery","clearQueue","moduleResponse","isError","queued","execNext","resource","status$1","initRedundancy","cfg","queries","cleanup","queryCallback","doneCallback","query$1","error","find","instance","setIndex","getIndex","emptyCallback$1","redundancyCache","getRedundancyCache","redundancy","cachedReundancy","sendAPIQuery","target","api","cached","moduleKey","emptyCallback","loadedNewIcons","iconsLoaderFlag","checkIconNamesForAPI","valid","invalid","parseLoaderResponse","checkMissing","pendingIcons","delete","parsed","console","parsePossiblyAsyncResponse","Promise","loadNewIcons","iconsToLoad","iconsQueueFlag","icons$1","customIconLoader","loadIcon","loadIcons","iconSet","cleanedIcons","sortedIcons","callCallback","newIcons","sources","lastProvider","lastPrefix","providerNewIcons","pendingQueue","fulfill","reject","iconObj","setCustomIconsLoader","loader","setCustomIconLoader","mergeCustomisations","valueType","separator","flipFromString","custom","flip","str","rotateFromString","defaultValue","units","value$1","parseInt","iconToHTML","renderAttribsHTML","attr","encodeSVGforURL","svg","svgToData","svgToURL","policy","createPolicy","window","trustedTypes","createHTML","s","cleanUpInnerHTML","html","defaultExtendedIconCustomisations","inline","svgDefaults","commonProps","display","monotoneProps","backgroundColor","coloredProps","propsToAdd","Image","Repeat","Size","propsToAddTo","WebkitMask","mask","background","inlineDefaults","fixSize","render","defaultProps","mode","style","customStyle","componentProps","classNames","className","ref","color","renderAttribs","verticalAlign","assign","localCounter","dangerouslySetInnerHTML","__html","useMask","document","_window","IconifyPreload","preload","e","IconifyProviders","IconComponent","mounted","setMounted","ssr","setAbort","getInitialState","state","setState","changeState","newState","JSON","stringify","updateState","_a","undefined","onLoad","call","children","fallback","Icon","_ref","InlineIcon","_api","buildIcon"],"sources":["/Users/toast/Desktop/Micheles Portfolio/wmskillas-Portfolio/wmskillas-portfolio/node_modules/@iconify/react/dist/iconify.js"],"sourcesContent":["'use client';\n\nimport { createElement, forwardRef, useState, useEffect } from 'react';\n\n/**\n* Resolve icon set icons\n*\n* Returns parent icon for each icon\n*/\nfunction getIconsTree(data, names) {\n\tconst icons = data.icons;\n\tconst aliases = data.aliases || Object.create(null);\n\tconst resolved = Object.create(null);\n\tfunction resolve(name) {\n\t\tif (icons[name]) return resolved[name] = [];\n\t\tif (!(name in resolved)) {\n\t\t\tresolved[name] = null;\n\t\t\tconst parent = aliases[name] && aliases[name].parent;\n\t\t\tconst value = parent && resolve(parent);\n\t\t\tif (value) resolved[name] = [parent].concat(value);\n\t\t}\n\t\treturn resolved[name];\n\t}\n\t(Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);\n\treturn resolved;\n}\n\n/**\n* Default values for dimensions\n*/\nconst defaultIconDimensions = Object.freeze({\n\tleft: 0,\n\ttop: 0,\n\twidth: 16,\n\theight: 16\n});\n/**\n* Default values for transformations\n*/\nconst defaultIconTransformations = Object.freeze({\n\trotate: 0,\n\tvFlip: false,\n\thFlip: false\n});\n/**\n* Default values for all optional IconifyIcon properties\n*/\nconst defaultIconProps = Object.freeze({\n\t...defaultIconDimensions,\n\t...defaultIconTransformations\n});\n/**\n* Default values for all properties used in ExtendedIconifyIcon\n*/\nconst defaultExtendedIconProps = Object.freeze({\n\t...defaultIconProps,\n\tbody: \"\",\n\thidden: false\n});\n\n/**\n* Merge transformations\n*/\nfunction mergeIconTransformations(obj1, obj2) {\n\tconst result = {};\n\tif (!obj1.hFlip !== !obj2.hFlip) result.hFlip = true;\n\tif (!obj1.vFlip !== !obj2.vFlip) result.vFlip = true;\n\tconst rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n\tif (rotate) result.rotate = rotate;\n\treturn result;\n}\n\n/**\n* Merge icon and alias\n*\n* Can also be used to merge default values and icon\n*/\nfunction mergeIconData(parent, child) {\n\tconst result = mergeIconTransformations(parent, child);\n\tfor (const key in defaultExtendedIconProps) if (key in defaultIconTransformations) {\n\t\tif (key in parent && !(key in result)) result[key] = defaultIconTransformations[key];\n\t} else if (key in child) result[key] = child[key];\n\telse if (key in parent) result[key] = parent[key];\n\treturn result;\n}\n\n/**\n* Get icon data, using prepared aliases tree\n*/\nfunction internalGetIconData(data, name, tree) {\n\tconst icons = data.icons;\n\tconst aliases = data.aliases || Object.create(null);\n\tlet currentProps = {};\n\tfunction parse(name$1) {\n\t\tcurrentProps = mergeIconData(icons[name$1] || aliases[name$1], currentProps);\n\t}\n\tparse(name);\n\ttree.forEach(parse);\n\treturn mergeIconData(data, currentProps);\n}\n\n/**\n* Extract icons from an icon set\n*\n* Returns list of icons that were found in icon set\n*/\nfunction parseIconSet(data, callback) {\n\tconst names = [];\n\tif (typeof data !== \"object\" || typeof data.icons !== \"object\") return names;\n\tif (data.not_found instanceof Array) data.not_found.forEach((name) => {\n\t\tcallback(name, null);\n\t\tnames.push(name);\n\t});\n\tconst tree = getIconsTree(data);\n\tfor (const name in tree) {\n\t\tconst item = tree[name];\n\t\tif (item) {\n\t\t\tcallback(name, internalGetIconData(data, name, item));\n\t\t\tnames.push(name);\n\t\t}\n\t}\n\treturn names;\n}\n\n/**\n* Optional properties\n*/\nconst optionalPropertyDefaults = {\n\tprovider: \"\",\n\taliases: {},\n\tnot_found: {},\n\t...defaultIconDimensions\n};\n/**\n* Check props\n*/\nfunction checkOptionalProps(item, defaults) {\n\tfor (const prop in defaults) if (prop in item && typeof item[prop] !== typeof defaults[prop]) return false;\n\treturn true;\n}\n/**\n* Validate icon set, return it as IconifyJSON on success, null on failure\n*\n* Unlike validateIconSet(), this function is very basic.\n* It does not throw exceptions, it does not check metadata, it does not fix stuff.\n*/\nfunction quicklyValidateIconSet(obj) {\n\tif (typeof obj !== \"object\" || obj === null) return null;\n\tconst data = obj;\n\tif (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") return null;\n\tif (!checkOptionalProps(obj, optionalPropertyDefaults)) return null;\n\tconst icons = data.icons;\n\tfor (const name in icons) {\n\t\tconst icon = icons[name];\n\t\tif (!name || typeof icon.body !== \"string\" || !checkOptionalProps(icon, defaultExtendedIconProps)) return null;\n\t}\n\tconst aliases = data.aliases || Object.create(null);\n\tfor (const name in aliases) {\n\t\tconst icon = aliases[name];\n\t\tconst parent = icon.parent;\n\t\tif (!name || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon, defaultExtendedIconProps)) return null;\n\t}\n\treturn data;\n}\n\n/**\n* Storage by provider and prefix\n*/\nconst dataStorage = Object.create(null);\n/**\n* Create new storage\n*/\nfunction newStorage(provider, prefix) {\n\treturn {\n\t\tprovider,\n\t\tprefix,\n\t\ticons: Object.create(null),\n\t\tmissing: /* @__PURE__ */ new Set()\n\t};\n}\n/**\n* Get storage for provider and prefix\n*/\nfunction getStorage(provider, prefix) {\n\tconst providerStorage = dataStorage[provider] || (dataStorage[provider] = Object.create(null));\n\treturn providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\n/**\n* Add icon set to storage\n*\n* Returns array of added icons\n*/\nfunction addIconSet(storage, data) {\n\tif (!quicklyValidateIconSet(data)) return [];\n\treturn parseIconSet(data, (name, icon) => {\n\t\tif (icon) storage.icons[name] = icon;\n\t\telse storage.missing.add(name);\n\t});\n}\n/**\n* Add icon to storage\n*/\nfunction addIconToStorage(storage, name, icon) {\n\ttry {\n\t\tif (typeof icon.body === \"string\") {\n\t\t\tstorage.icons[name] = { ...icon };\n\t\t\treturn true;\n\t\t}\n\t} catch (err) {}\n\treturn false;\n}\n/**\n* List available icons\n*/\nfunction listIcons(provider, prefix) {\n\tlet allIcons = [];\n\tconst providers = typeof provider === \"string\" ? [provider] : Object.keys(dataStorage);\n\tproviders.forEach((provider$1) => {\n\t\tconst prefixes = typeof provider$1 === \"string\" && typeof prefix === \"string\" ? [prefix] : Object.keys(dataStorage[provider$1] || {});\n\t\tprefixes.forEach((prefix$1) => {\n\t\t\tconst storage = getStorage(provider$1, prefix$1);\n\t\t\tallIcons = allIcons.concat(Object.keys(storage.icons).map((name) => (provider$1 !== \"\" ? \"@\" + provider$1 + \":\" : \"\") + prefix$1 + \":\" + name));\n\t\t});\n\t});\n\treturn allIcons;\n}\n\n/**\n* Expression to test part of icon name.\n*\n* Used when loading icons from Iconify API due to project naming convension.\n* Ignored when using custom icon sets - convension does not apply.\n*/\nconst matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\n/**\n* Convert string icon name to IconifyIconName object.\n*/\nconst stringToIcon = (value, validate, allowSimpleName, provider = \"\") => {\n\tconst colonSeparated = value.split(\":\");\n\tif (value.slice(0, 1) === \"@\") {\n\t\tif (colonSeparated.length < 2 || colonSeparated.length > 3) return null;\n\t\tprovider = colonSeparated.shift().slice(1);\n\t}\n\tif (colonSeparated.length > 3 || !colonSeparated.length) return null;\n\tif (colonSeparated.length > 1) {\n\t\tconst name$1 = colonSeparated.pop();\n\t\tconst prefix = colonSeparated.pop();\n\t\tconst result = {\n\t\t\tprovider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n\t\t\tprefix,\n\t\t\tname: name$1\n\t\t};\n\t\treturn validate && !validateIconName(result) ? null : result;\n\t}\n\tconst name = colonSeparated[0];\n\tconst dashSeparated = name.split(\"-\");\n\tif (dashSeparated.length > 1) {\n\t\tconst result = {\n\t\t\tprovider,\n\t\t\tprefix: dashSeparated.shift(),\n\t\t\tname: dashSeparated.join(\"-\")\n\t\t};\n\t\treturn validate && !validateIconName(result) ? null : result;\n\t}\n\tif (allowSimpleName && provider === \"\") {\n\t\tconst result = {\n\t\t\tprovider,\n\t\t\tprefix: \"\",\n\t\t\tname\n\t\t};\n\t\treturn validate && !validateIconName(result, allowSimpleName) ? null : result;\n\t}\n\treturn null;\n};\n/**\n* Check if icon is valid.\n*\n* This function is not part of stringToIcon because validation is not needed for most code.\n*/\nconst validateIconName = (icon, allowSimpleName) => {\n\tif (!icon) return false;\n\treturn !!((allowSimpleName && icon.prefix === \"\" || !!icon.prefix) && !!icon.name);\n};\n\n/**\n* Allow storing icons without provider or prefix, making it possible to store icons like \"home\"\n*/\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n\tif (typeof allow === \"boolean\") simpleNames = allow;\n\treturn simpleNames;\n}\n/**\n* Get icon data\n*\n* Returns:\n* - IconifyIcon on success, object directly from storage so don't modify it\n* - null if icon is marked as missing (returned in `not_found` property from API, so don't bother sending API requests)\n* - undefined if icon is missing in storage\n*/\nfunction getIconData(name) {\n\tconst icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n\tif (icon) {\n\t\tconst storage = getStorage(icon.provider, icon.prefix);\n\t\tconst iconName = icon.name;\n\t\treturn storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n\t}\n}\n/**\n* Add one icon\n*/\nfunction addIcon(name, data) {\n\tconst icon = stringToIcon(name, true, simpleNames);\n\tif (!icon) return false;\n\tconst storage = getStorage(icon.provider, icon.prefix);\n\tif (data) return addIconToStorage(storage, icon.name, data);\n\telse {\n\t\tstorage.missing.add(icon.name);\n\t\treturn true;\n\t}\n}\n/**\n* Add icon set\n*/\nfunction addCollection(data, provider) {\n\tif (typeof data !== \"object\") return false;\n\tif (typeof provider !== \"string\") provider = data.provider || \"\";\n\tif (simpleNames && !provider && !data.prefix) {\n\t\tlet added = false;\n\t\tif (quicklyValidateIconSet(data)) {\n\t\t\tdata.prefix = \"\";\n\t\t\tparseIconSet(data, (name, icon) => {\n\t\t\t\tif (addIcon(name, icon)) added = true;\n\t\t\t});\n\t\t}\n\t\treturn added;\n\t}\n\tconst prefix = data.prefix;\n\tif (!validateIconName({\n\t\tprefix,\n\t\tname: \"a\"\n\t})) return false;\n\tconst storage = getStorage(provider, prefix);\n\treturn !!addIconSet(storage, data);\n}\n/**\n* Check if icon data is available\n*/\nfunction iconLoaded(name) {\n\treturn !!getIconData(name);\n}\n/**\n* Get full icon\n*/\nfunction getIcon(name) {\n\tconst result = getIconData(name);\n\treturn result ? {\n\t\t...defaultIconProps,\n\t\t...result\n\t} : result;\n}\n\n/**\n* Default icon customisations values\n*/\nconst defaultIconSizeCustomisations = Object.freeze({\n\twidth: null,\n\theight: null\n});\nconst defaultIconCustomisations = Object.freeze({\n\t...defaultIconSizeCustomisations,\n\t...defaultIconTransformations\n});\n\n/**\n* Regular expressions for calculating dimensions\n*/\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n\tif (ratio === 1) return size;\n\tprecision = precision || 100;\n\tif (typeof size === \"number\") return Math.ceil(size * ratio * precision) / precision;\n\tif (typeof size !== \"string\") return size;\n\tconst oldParts = size.split(unitsSplit);\n\tif (oldParts === null || !oldParts.length) return size;\n\tconst newParts = [];\n\tlet code = oldParts.shift();\n\tlet isNumber = unitsTest.test(code);\n\twhile (true) {\n\t\tif (isNumber) {\n\t\t\tconst num = parseFloat(code);\n\t\t\tif (isNaN(num)) newParts.push(code);\n\t\t\telse newParts.push(Math.ceil(num * ratio * precision) / precision);\n\t\t} else newParts.push(code);\n\t\tcode = oldParts.shift();\n\t\tif (code === void 0) return newParts.join(\"\");\n\t\tisNumber = !isNumber;\n\t}\n}\n\nfunction splitSVGDefs(content, tag = \"defs\") {\n\tlet defs = \"\";\n\tconst index = content.indexOf(\"<\" + tag);\n\twhile (index >= 0) {\n\t\tconst start = content.indexOf(\">\", index);\n\t\tconst end = content.indexOf(\"</\" + tag);\n\t\tif (start === -1 || end === -1) break;\n\t\tconst endEnd = content.indexOf(\">\", end);\n\t\tif (endEnd === -1) break;\n\t\tdefs += content.slice(start + 1, end).trim();\n\t\tcontent = content.slice(0, index).trim() + content.slice(endEnd + 1);\n\t}\n\treturn {\n\t\tdefs,\n\t\tcontent\n\t};\n}\n/**\n* Merge defs and content\n*/\nfunction mergeDefsAndContent(defs, content) {\n\treturn defs ? \"<defs>\" + defs + \"</defs>\" + content : content;\n}\n/**\n* Wrap SVG content, without wrapping definitions\n*/\nfunction wrapSVGContent(body, start, end) {\n\tconst split = splitSVGDefs(body);\n\treturn mergeDefsAndContent(split.defs, start + split.content + end);\n}\n\n/**\n* Check if value should be unset. Allows multiple keywords\n*/\nconst isUnsetKeyword = (value) => value === \"unset\" || value === \"undefined\" || value === \"none\";\n/**\n* Get SVG attributes and content from icon + customisations\n*\n* Does not generate style to make it compatible with frameworks that use objects for style, such as React.\n* Instead, it generates 'inline' value. If true, rendering engine should add verticalAlign: -0.125em to icon.\n*\n* Customisations should be normalised by platform specific parser.\n* Result should be converted to <svg> by platform specific parser.\n* Use replaceIDs to generate unique IDs for body.\n*/\nfunction iconToSVG(icon, customisations) {\n\tconst fullIcon = {\n\t\t...defaultIconProps,\n\t\t...icon\n\t};\n\tconst fullCustomisations = {\n\t\t...defaultIconCustomisations,\n\t\t...customisations\n\t};\n\tconst box = {\n\t\tleft: fullIcon.left,\n\t\ttop: fullIcon.top,\n\t\twidth: fullIcon.width,\n\t\theight: fullIcon.height\n\t};\n\tlet body = fullIcon.body;\n\t[fullIcon, fullCustomisations].forEach((props) => {\n\t\tconst transformations = [];\n\t\tconst hFlip = props.hFlip;\n\t\tconst vFlip = props.vFlip;\n\t\tlet rotation = props.rotate;\n\t\tif (hFlip) if (vFlip) rotation += 2;\n\t\telse {\n\t\t\ttransformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n\t\t\ttransformations.push(\"scale(-1 1)\");\n\t\t\tbox.top = box.left = 0;\n\t\t}\n\t\telse if (vFlip) {\n\t\t\ttransformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n\t\t\ttransformations.push(\"scale(1 -1)\");\n\t\t\tbox.top = box.left = 0;\n\t\t}\n\t\tlet tempValue;\n\t\tif (rotation < 0) rotation -= Math.floor(rotation / 4) * 4;\n\t\trotation = rotation % 4;\n\t\tswitch (rotation) {\n\t\t\tcase 1:\n\t\t\t\ttempValue = box.height / 2 + box.top;\n\t\t\t\ttransformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttransformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttempValue = box.width / 2 + box.left;\n\t\t\t\ttransformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n\t\t\t\tbreak;\n\t\t}\n\t\tif (rotation % 2 === 1) {\n\t\t\tif (box.left !== box.top) {\n\t\t\t\ttempValue = box.left;\n\t\t\t\tbox.left = box.top;\n\t\t\t\tbox.top = tempValue;\n\t\t\t}\n\t\t\tif (box.width !== box.height) {\n\t\t\t\ttempValue = box.width;\n\t\t\t\tbox.width = box.height;\n\t\t\t\tbox.height = tempValue;\n\t\t\t}\n\t\t}\n\t\tif (transformations.length) body = wrapSVGContent(body, \"<g transform=\\\"\" + transformations.join(\" \") + \"\\\">\", \"</g>\");\n\t});\n\tconst customisationsWidth = fullCustomisations.width;\n\tconst customisationsHeight = fullCustomisations.height;\n\tconst boxWidth = box.width;\n\tconst boxHeight = box.height;\n\tlet width;\n\tlet height;\n\tif (customisationsWidth === null) {\n\t\theight = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n\t\twidth = calculateSize(height, boxWidth / boxHeight);\n\t} else {\n\t\twidth = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n\t\theight = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n\t}\n\tconst attributes = {};\n\tconst setAttr = (prop, value) => {\n\t\tif (!isUnsetKeyword(value)) attributes[prop] = value.toString();\n\t};\n\tsetAttr(\"width\", width);\n\tsetAttr(\"height\", height);\n\tconst viewBox = [\n\t\tbox.left,\n\t\tbox.top,\n\t\tboxWidth,\n\t\tboxHeight\n\t];\n\tattributes.viewBox = viewBox.join(\" \");\n\treturn {\n\t\tattributes,\n\t\tviewBox,\n\t\tbody\n\t};\n}\n\n/**\n* IDs usage:\n*\n* id=\"{id}\"\n* xlink:href=\"#{id}\"\n* url(#{id})\n*\n* From SVG animations:\n*\n* begin=\"0;{id}.end\"\n* begin=\"{id}.end\"\n* begin=\"{id}.click\"\n*/\n/**\n* Regular expression for finding ids\n*/\nconst regex = /\\sid=\"(\\S+)\"/g;\n/**\n* New random-ish prefix for ids\n*\n* Do not use dash, it cannot be used in SVG 2 animations\n*/\nconst randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\n/**\n* Counter for ids, increasing with every replacement\n*/\nlet counter = 0;\n/**\n* Replace IDs in SVG output with unique IDs\n*/\nfunction replaceIDs(body, prefix = randomPrefix) {\n\tconst ids = [];\n\tlet match;\n\twhile (match = regex.exec(body)) ids.push(match[1]);\n\tif (!ids.length) return body;\n\tconst suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n\tids.forEach((id) => {\n\t\tconst newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n\t\tconst escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\t\tbody = body.replace(new RegExp(\"([#;\\\"])(\" + escapedID + \")([\\\")]|\\\\.[a-z])\", \"g\"), \"$1\" + newID + suffix + \"$3\");\n\t});\n\tbody = body.replace(new RegExp(suffix, \"g\"), \"\");\n\treturn body;\n}\n\n/**\n* Local storate types and entries\n*/\nconst storage = Object.create(null);\n/**\n* Set API module\n*/\nfunction setAPIModule(provider, item) {\n\tstorage[provider] = item;\n}\n/**\n* Get API module\n*/\nfunction getAPIModule(provider) {\n\treturn storage[provider] || storage[\"\"];\n}\n\n/**\n* Create full API configuration from partial data\n*/\nfunction createAPIConfig(source) {\n\tlet resources;\n\tif (typeof source.resources === \"string\") resources = [source.resources];\n\telse {\n\t\tresources = source.resources;\n\t\tif (!(resources instanceof Array) || !resources.length) return null;\n\t}\n\tconst result = {\n\t\tresources,\n\t\tpath: source.path || \"/\",\n\t\tmaxURL: source.maxURL || 500,\n\t\trotate: source.rotate || 750,\n\t\ttimeout: source.timeout || 5e3,\n\t\trandom: source.random === true,\n\t\tindex: source.index || 0,\n\t\tdataAfterTimeout: source.dataAfterTimeout !== false\n\t};\n\treturn result;\n}\n/**\n* Local storage\n*/\nconst configStorage = Object.create(null);\n/**\n* Redundancy for API servers.\n*\n* API should have very high uptime because of implemented redundancy at server level, but\n* sometimes bad things happen. On internet 100% uptime is not possible.\n*\n* There could be routing problems. Server might go down for whatever reason, but it takes\n* few minutes to detect that downtime, so during those few minutes API might not be accessible.\n*\n* This script has some redundancy to mitigate possible network issues.\n*\n* If one host cannot be reached in 'rotate' (750 by default) ms, script will try to retrieve\n* data from different host. Hosts have different configurations, pointing to different\n* API servers hosted at different providers.\n*/\nconst fallBackAPISources = [\"https://api.simplesvg.com\", \"https://api.unisvg.com\"];\nconst fallBackAPI = [];\nwhile (fallBackAPISources.length > 0) if (fallBackAPISources.length === 1) fallBackAPI.push(fallBackAPISources.shift());\nelse if (Math.random() > .5) fallBackAPI.push(fallBackAPISources.shift());\nelse fallBackAPI.push(fallBackAPISources.pop());\nconfigStorage[\"\"] = createAPIConfig({ resources: [\"https://api.iconify.design\"].concat(fallBackAPI) });\n/**\n* Add custom config for provider\n*/\nfunction addAPIProvider(provider, customConfig) {\n\tconst config = createAPIConfig(customConfig);\n\tif (config === null) return false;\n\tconfigStorage[provider] = config;\n\treturn true;\n}\n/**\n* Get API configuration\n*/\nfunction getAPIConfig(provider) {\n\treturn configStorage[provider];\n}\n/**\n* List API providers\n*/\nfunction listAPIProviders() {\n\treturn Object.keys(configStorage);\n}\n\nconst detectFetch = () => {\n\tlet callback;\n\ttry {\n\t\tcallback = fetch;\n\t\tif (typeof callback === \"function\") return callback;\n\t} catch (err) {}\n};\n/**\n* Fetch function\n*/\nlet fetchModule = detectFetch();\n/**\n* Set custom fetch() function\n*/\nfunction setFetch(fetch$1) {\n\tfetchModule = fetch$1;\n}\n/**\n* Get fetch() function. Used by Icon Finder Core\n*/\nfunction getFetch() {\n\treturn fetchModule;\n}\n/**\n* Calculate maximum icons list length for prefix\n*/\nfunction calculateMaxLength(provider, prefix) {\n\tconst config = getAPIConfig(provider);\n\tif (!config) return 0;\n\tlet result;\n\tif (!config.maxURL) result = 0;\n\telse {\n\t\tlet maxHostLength = 0;\n\t\tconfig.resources.forEach((item) => {\n\t\t\tconst host = item;\n\t\t\tmaxHostLength = Math.max(maxHostLength, host.length);\n\t\t});\n\t\tconst url = prefix + \".json?icons=\";\n\t\tresult = config.maxURL - maxHostLength - config.path.length - url.length;\n\t}\n\treturn result;\n}\n/**\n* Should query be aborted, based on last HTTP status\n*/\nfunction shouldAbort(status) {\n\treturn status === 404;\n}\n/**\n* Prepare params\n*/\nconst prepare = (provider, prefix, icons) => {\n\tconst results = [];\n\tconst maxLength = calculateMaxLength(provider, prefix);\n\tconst type = \"icons\";\n\tlet item = {\n\t\ttype,\n\t\tprovider,\n\t\tprefix,\n\t\ticons: []\n\t};\n\tlet length = 0;\n\ticons.forEach((name, index) => {\n\t\tlength += name.length + 1;\n\t\tif (length >= maxLength && index > 0) {\n\t\t\tresults.push(item);\n\t\t\titem = {\n\t\t\t\ttype,\n\t\t\t\tprovider,\n\t\t\t\tprefix,\n\t\t\t\ticons: []\n\t\t\t};\n\t\t\tlength = name.length;\n\t\t}\n\t\titem.icons.push(name);\n\t});\n\tresults.push(item);\n\treturn results;\n};\n/**\n* Get path\n*/\nfunction getPath(provider) {\n\tif (typeof provider === \"string\") {\n\t\tconst config = getAPIConfig(provider);\n\t\tif (config) return config.path;\n\t}\n\treturn \"/\";\n}\n/**\n* Load icons\n*/\nconst send = (host, params, callback) => {\n\tif (!fetchModule) {\n\t\tcallback(\"abort\", 424);\n\t\treturn;\n\t}\n\tlet path = getPath(params.provider);\n\tswitch (params.type) {\n\t\tcase \"icons\": {\n\t\t\tconst prefix = params.prefix;\n\t\t\tconst icons = params.icons;\n\t\t\tconst iconsList = icons.join(\",\");\n\t\t\tconst urlParams = new URLSearchParams({ icons: iconsList });\n\t\t\tpath += prefix + \".json?\" + urlParams.toString();\n\t\t\tbreak;\n\t\t}\n\t\tcase \"custom\": {\n\t\t\tconst uri = params.uri;\n\t\t\tpath += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcallback(\"abort\", 400);\n\t\t\treturn;\n\t}\n\tlet defaultError = 503;\n\tfetchModule(host + path).then((response) => {\n\t\tconst status = response.status;\n\t\tif (status !== 200) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tcallback(shouldAbort(status) ? \"abort\" : \"next\", status);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tdefaultError = 501;\n\t\treturn response.json();\n\t}).then((data) => {\n\t\tif (typeof data !== \"object\" || data === null) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (data === 404) callback(\"abort\", data);\n\t\t\t\telse callback(\"next\", defaultError);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tsetTimeout(() => {\n\t\t\tcallback(\"success\", data);\n\t\t});\n\t}).catch(() => {\n\t\tcallback(\"next\", defaultError);\n\t});\n};\n/**\n* Export module\n*/\nconst fetchAPIModule = {\n\tprepare,\n\tsend\n};\n\n/**\n* Remove callback\n*/\nfunction removeCallback(storages, id) {\n\tstorages.forEach((storage) => {\n\t\tconst items = storage.loaderCallbacks;\n\t\tif (items) storage.loaderCallbacks = items.filter((row) => row.id !== id);\n\t});\n}\n/**\n* Update all callbacks for provider and prefix\n*/\nfunction updateCallbacks(storage) {\n\tif (!storage.pendingCallbacksFlag) {\n\t\tstorage.pendingCallbacksFlag = true;\n\t\tsetTimeout(() => {\n\t\t\tstorage.pendingCallbacksFlag = false;\n\t\t\tconst items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n\t\t\tif (!items.length) return;\n\t\t\tlet hasPending = false;\n\t\t\tconst provider = storage.provider;\n\t\t\tconst prefix = storage.prefix;\n\t\t\titems.forEach((item) => {\n\t\t\t\tconst icons = item.icons;\n\t\t\t\tconst oldLength = icons.pending.length;\n\t\t\t\ticons.pending = icons.pending.filter((icon) => {\n\t\t\t\t\tif (icon.prefix !== prefix) return true;\n\t\t\t\t\tconst name = icon.name;\n\t\t\t\t\tif (storage.icons[name]) icons.loaded.push({\n\t\t\t\t\t\tprovider,\n\t\t\t\t\t\tprefix,\n\t\t\t\t\t\tname\n\t\t\t\t\t});\n\t\t\t\t\telse if (storage.missing.has(name)) icons.missing.push({\n\t\t\t\t\t\tprovider,\n\t\t\t\t\t\tprefix,\n\t\t\t\t\t\tname\n\t\t\t\t\t});\n\t\t\t\t\telse {\n\t\t\t\t\t\thasPending = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t\tif (icons.pending.length !== oldLength) {\n\t\t\t\t\tif (!hasPending) removeCallback([storage], item.id);\n\t\t\t\t\titem.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n/**\n* Unique id counter for callbacks\n*/\nlet idCounter = 0;\n/**\n* Add callback\n*/\nfunction storeCallback(callback, icons, pendingSources) {\n\tconst id = idCounter++;\n\tconst abort = removeCallback.bind(null, pendingSources, id);\n\tif (!icons.pending.length) return abort;\n\tconst item = {\n\t\tid,\n\t\ticons,\n\t\tcallback,\n\t\tabort\n\t};\n\tpendingSources.forEach((storage) => {\n\t\t(storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n\t});\n\treturn abort;\n}\n\n/**\n* Check if icons have been loaded\n*/\nfunction sortIcons(icons) {\n\tconst result = {\n\t\tloaded: [],\n\t\tmissing: [],\n\t\tpending: []\n\t};\n\tconst storage = Object.create(null);\n\ticons.sort((a, b) => {\n\t\tif (a.provider !== b.provider) return a.provider.localeCompare(b.provider);\n\t\tif (a.prefix !== b.prefix) return a.prefix.localeCompare(b.prefix);\n\t\treturn a.name.localeCompare(b.name);\n\t});\n\tlet lastIcon = {\n\t\tprovider: \"\",\n\t\tprefix: \"\",\n\t\tname: \"\"\n\t};\n\ticons.forEach((icon) => {\n\t\tif (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) return;\n\t\tlastIcon = icon;\n\t\tconst provider = icon.provider;\n\t\tconst prefix = icon.prefix;\n\t\tconst name = icon.name;\n\t\tconst providerStorage = storage[provider] || (storage[provider] = Object.create(null));\n\t\tconst localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n\t\tlet list;\n\t\tif (name in localStorage.icons) list = result.loaded;\n\t\telse if (prefix === \"\" || localStorage.missing.has(name)) list = result.missing;\n\t\telse list = result.pending;\n\t\tconst item = {\n\t\t\tprovider,\n\t\t\tprefix,\n\t\t\tname\n\t\t};\n\t\tlist.push(item);\n\t});\n\treturn result;\n}\n\n/**\n* Convert icons list from string/icon mix to icons and validate them\n*/\nfunction listToIcons(list, validate = true, simpleNames = false) {\n\tconst result = [];\n\tlist.forEach((item) => {\n\t\tconst icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n\t\tif (icon) result.push(icon);\n\t});\n\treturn result;\n}\n\n/**\n* Default RedundancyConfig for API calls\n*/\nconst defaultConfig = {\n\tresources: [],\n\tindex: 0,\n\ttimeout: 2e3,\n\trotate: 750,\n\trandom: false,\n\tdataAfterTimeout: false\n};\n\n/**\n* Send query\n*/\nfunction sendQuery(config, payload, query, done) {\n\tconst resourcesCount = config.resources.length;\n\tconst startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n\tlet resources;\n\tif (config.random) {\n\t\tlet list = config.resources.slice(0);\n\t\tresources = [];\n\t\twhile (list.length > 1) {\n\t\t\tconst nextIndex = Math.floor(Math.random() * list.length);\n\t\t\tresources.push(list[nextIndex]);\n\t\t\tlist = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n\t\t}\n\t\tresources = resources.concat(list);\n\t} else resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n\tconst startTime = Date.now();\n\tlet status = \"pending\";\n\tlet queriesSent = 0;\n\tlet lastError;\n\tlet timer = null;\n\tlet queue = [];\n\tlet doneCallbacks = [];\n\tif (typeof done === \"function\") doneCallbacks.push(done);\n\t/**\n\t* Reset timer\n\t*/\n\tfunction resetTimer() {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t}\n\t}\n\t/**\n\t* Abort everything\n\t*/\n\tfunction abort() {\n\t\tif (status === \"pending\") status = \"aborted\";\n\t\tresetTimer();\n\t\tqueue.forEach((item) => {\n\t\t\tif (item.status === \"pending\") item.status = \"aborted\";\n\t\t});\n\t\tqueue = [];\n\t}\n\t/**\n\t* Add / replace callback to call when execution is complete.\n\t* This can be used to abort pending query implementations when query is complete or aborted.\n\t*/\n\tfunction subscribe(callback, overwrite) {\n\t\tif (overwrite) doneCallbacks = [];\n\t\tif (typeof callback === \"function\") doneCallbacks.push(callback);\n\t}\n\t/**\n\t* Get query status\n\t*/\n\tfunction getQueryStatus() {\n\t\treturn {\n\t\t\tstartTime,\n\t\t\tpayload,\n\t\t\tstatus,\n\t\t\tqueriesSent,\n\t\t\tqueriesPending: queue.length,\n\t\t\tsubscribe,\n\t\t\tabort\n\t\t};\n\t}\n\t/**\n\t* Fail query\n\t*/\n\tfunction failQuery() {\n\t\tstatus = \"failed\";\n\t\tdoneCallbacks.forEach((callback) => {\n\t\t\tcallback(void 0, lastError);\n\t\t});\n\t}\n\t/**\n\t* Clear queue\n\t*/\n\tfunction clearQueue() {\n\t\tqueue.forEach((item) => {\n\t\t\tif (item.status === \"pending\") item.status = \"aborted\";\n\t\t});\n\t\tqueue = [];\n\t}\n\t/**\n\t* Got response from module\n\t*/\n\tfunction moduleResponse(item, response, data) {\n\t\tconst isError = response !== \"success\";\n\t\tqueue = queue.filter((queued) => queued !== item);\n\t\tswitch (status) {\n\t\t\tcase \"pending\": break;\n\t\t\tcase \"failed\":\n\t\t\t\tif (isError || !config.dataAfterTimeout) return;\n\t\t\t\tbreak;\n\t\t\tdefault: return;\n\t\t}\n\t\tif (response === \"abort\") {\n\t\t\tlastError = data;\n\t\t\tfailQuery();\n\t\t\treturn;\n\t\t}\n\t\tif (isError) {\n\t\t\tlastError = data;\n\t\t\tif (!queue.length) if (!resources.length) failQuery();\n\t\t\telse execNext();\n\t\t\treturn;\n\t\t}\n\t\tresetTimer();\n\t\tclearQueue();\n\t\tif (!config.random) {\n\t\t\tconst index = config.resources.indexOf(item.resource);\n\t\t\tif (index !== -1 && index !== config.index) config.index = index;\n\t\t}\n\t\tstatus = \"completed\";\n\t\tdoneCallbacks.forEach((callback) => {\n\t\t\tcallback(data);\n\t\t});\n\t}\n\t/**\n\t* Execute next query\n\t*/\n\tfunction execNext() {\n\t\tif (status !== \"pending\") return;\n\t\tresetTimer();\n\t\tconst resource = resources.shift();\n\t\tif (resource === void 0) {\n\t\t\tif (queue.length) {\n\t\t\t\ttimer = setTimeout(() => {\n\t\t\t\t\tresetTimer();\n\t\t\t\t\tif (status === \"pending\") {\n\t\t\t\t\t\tclearQueue();\n\t\t\t\t\t\tfailQuery();\n\t\t\t\t\t}\n\t\t\t\t}, config.timeout);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfailQuery();\n\t\t\treturn;\n\t\t}\n\t\tconst item = {\n\t\t\tstatus: \"pending\",\n\t\t\tresource,\n\t\t\tcallback: (status$1, data) => {\n\t\t\t\tmoduleResponse(item, status$1, data);\n\t\t\t}\n\t\t};\n\t\tqueue.push(item);\n\t\tqueriesSent++;\n\t\ttimer = setTimeout(execNext, config.rotate);\n\t\tquery(resource, payload, item.callback);\n\t}\n\tsetTimeout(execNext);\n\treturn getQueryStatus;\n}\n\n/**\n* Redundancy instance\n*/\nfunction initRedundancy(cfg) {\n\tconst config = {\n\t\t...defaultConfig,\n\t\t...cfg\n\t};\n\tlet queries = [];\n\t/**\n\t* Remove aborted and completed queries\n\t*/\n\tfunction cleanup() {\n\t\tqueries = queries.filter((item) => item().status === \"pending\");\n\t}\n\t/**\n\t* Send query\n\t*/\n\tfunction query(payload, queryCallback, doneCallback) {\n\t\tconst query$1 = sendQuery(config, payload, queryCallback, (data, error) => {\n\t\t\tcleanup();\n\t\t\tif (doneCallback) doneCallback(data, error);\n\t\t});\n\t\tqueries.push(query$1);\n\t\treturn query$1;\n\t}\n\t/**\n\t* Find instance\n\t*/\n\tfunction find(callback) {\n\t\treturn queries.find((value) => {\n\t\t\treturn callback(value);\n\t\t}) || null;\n\t}\n\tconst instance = {\n\t\tquery,\n\t\tfind,\n\t\tsetIndex: (index) => {\n\t\t\tconfig.index = index;\n\t\t},\n\t\tgetIndex: () => config.index,\n\t\tcleanup\n\t};\n\treturn instance;\n}\n\nfunction emptyCallback$1() {}\nconst redundancyCache = Object.create(null);\n/**\n* Get Redundancy instance for provider\n*/\nfunction getRedundancyCache(provider) {\n\tif (!redundancyCache[provider]) {\n\t\tconst config = getAPIConfig(provider);\n\t\tif (!config) return;\n\t\tconst redundancy = initRedundancy(config);\n\t\tconst cachedReundancy = {\n\t\t\tconfig,\n\t\t\tredundancy\n\t\t};\n\t\tredundancyCache[provider] = cachedReundancy;\n\t}\n\treturn redundancyCache[provider];\n}\n/**\n* Send API query\n*/\nfunction sendAPIQuery(target, query, callback) {\n\tlet redundancy;\n\tlet send;\n\tif (typeof target === \"string\") {\n\t\tconst api = getAPIModule(target);\n\t\tif (!api) {\n\t\t\tcallback(void 0, 424);\n\t\t\treturn emptyCallback$1;\n\t\t}\n\t\tsend = api.send;\n\t\tconst cached = getRedundancyCache(target);\n\t\tif (cached) redundancy = cached.redundancy;\n\t} else {\n\t\tconst config = createAPIConfig(target);\n\t\tif (config) {\n\t\t\tredundancy = initRedundancy(config);\n\t\t\tconst moduleKey = target.resources ? target.resources[0] : \"\";\n\t\t\tconst api = getAPIModule(moduleKey);\n\t\t\tif (api) send = api.send;\n\t\t}\n\t}\n\tif (!redundancy || !send) {\n\t\tcallback(void 0, 424);\n\t\treturn emptyCallback$1;\n\t}\n\treturn redundancy.query(query, send, callback)().abort;\n}\n\nfunction emptyCallback() {}\n/**\n* Function called when new icons have been loaded\n*/\nfunction loadedNewIcons(storage) {\n\tif (!storage.iconsLoaderFlag) {\n\t\tstorage.iconsLoaderFlag = true;\n\t\tsetTimeout(() => {\n\t\t\tstorage.iconsLoaderFlag = false;\n\t\t\tupdateCallbacks(storage);\n\t\t});\n\t}\n}\n/**\n* Check icon names for API\n*/\nfunction checkIconNamesForAPI(icons) {\n\tconst valid = [];\n\tconst invalid = [];\n\ticons.forEach((name) => {\n\t\t(name.match(matchIconName) ? valid : invalid).push(name);\n\t});\n\treturn {\n\t\tvalid,\n\t\tinvalid\n\t};\n}\n/**\n* Parse loader response\n*/\nfunction parseLoaderResponse(storage, icons, data) {\n\tfunction checkMissing() {\n\t\tconst pending = storage.pendingIcons;\n\t\ticons.forEach((name) => {\n\t\t\tif (pending) pending.delete(name);\n\t\t\tif (!storage.icons[name]) storage.missing.add(name);\n\t\t});\n\t}\n\tif (data && typeof data === \"object\") try {\n\t\tconst parsed = addIconSet(storage, data);\n\t\tif (!parsed.length) {\n\t\t\tcheckMissing();\n\t\t\treturn;\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err);\n\t}\n\tcheckMissing();\n\tloadedNewIcons(storage);\n}\n/**\n* Handle response that can be async\n*/\nfunction parsePossiblyAsyncResponse(response, callback) {\n\tif (response instanceof Promise) response.then((data) => {\n\t\tcallback(data);\n\t}).catch(() => {\n\t\tcallback(null);\n\t});\n\telse callback(response);\n}\n/**\n* Load icons\n*/\nfunction loadNewIcons(storage, icons) {\n\tif (!storage.iconsToLoad) storage.iconsToLoad = icons;\n\telse storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n\tif (!storage.iconsQueueFlag) {\n\t\tstorage.iconsQueueFlag = true;\n\t\tsetTimeout(() => {\n\t\t\tstorage.iconsQueueFlag = false;\n\t\t\tconst { provider, prefix } = storage;\n\t\t\tconst icons$1 = storage.iconsToLoad;\n\t\t\tdelete storage.iconsToLoad;\n\t\t\tif (!icons$1 || !icons$1.length) return;\n\t\t\tconst customIconLoader = storage.loadIcon;\n\t\t\tif (storage.loadIcons && (icons$1.length > 1 || !customIconLoader)) {\n\t\t\t\tparsePossiblyAsyncResponse(storage.loadIcons(icons$1, prefix, provider), (data) => {\n\t\t\t\t\tparseLoaderResponse(storage, icons$1, data);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (customIconLoader) {\n\t\t\t\ticons$1.forEach((name) => {\n\t\t\t\t\tconst response = customIconLoader(name, prefix, provider);\n\t\t\t\t\tparsePossiblyAsyncResponse(response, (data) => {\n\t\t\t\t\t\tconst iconSet = data ? {\n\t\t\t\t\t\t\tprefix,\n\t\t\t\t\t\t\ticons: { [name]: data }\n\t\t\t\t\t\t} : null;\n\t\t\t\t\t\tparseLoaderResponse(storage, [name], iconSet);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst { valid, invalid } = checkIconNamesForAPI(icons$1);\n\t\t\tif (invalid.length) parseLoaderResponse(storage, invalid, null);\n\t\t\tif (!valid.length) return;\n\t\t\tconst api = prefix.match(matchIconName) ? getAPIModule(provider) : null;\n\t\t\tif (!api) {\n\t\t\t\tparseLoaderResponse(storage, valid, null);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst params = api.prepare(provider, prefix, valid);\n\t\t\tparams.forEach((item) => {\n\t\t\t\tsendAPIQuery(provider, item, (data) => {\n\t\t\t\t\tparseLoaderResponse(storage, item.icons, data);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n}\n/**\n* Load icons\n*/\nconst loadIcons = (icons, callback) => {\n\tconst cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n\tconst sortedIcons = sortIcons(cleanedIcons);\n\tif (!sortedIcons.pending.length) {\n\t\tlet callCallback = true;\n\t\tif (callback) setTimeout(() => {\n\t\t\tif (callCallback) callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n\t\t});\n\t\treturn () => {\n\t\t\tcallCallback = false;\n\t\t};\n\t}\n\tconst newIcons = Object.create(null);\n\tconst sources = [];\n\tlet lastProvider, lastPrefix;\n\tsortedIcons.pending.forEach((icon) => {\n\t\tconst { provider, prefix } = icon;\n\t\tif (prefix === lastPrefix && provider === lastProvider) return;\n\t\tlastProvider = provider;\n\t\tlastPrefix = prefix;\n\t\tsources.push(getStorage(provider, prefix));\n\t\tconst providerNewIcons = newIcons[provider] || (newIcons[provider] = Object.create(null));\n\t\tif (!providerNewIcons[prefix]) providerNewIcons[prefix] = [];\n\t});\n\tsortedIcons.pending.forEach((icon) => {\n\t\tconst { provider, prefix, name } = icon;\n\t\tconst storage = getStorage(provider, prefix);\n\t\tconst pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n\t\tif (!pendingQueue.has(name)) {\n\t\t\tpendingQueue.add(name);\n\t\t\tnewIcons[provider][prefix].push(name);\n\t\t}\n\t});\n\tsources.forEach((storage) => {\n\t\tconst list = newIcons[storage.provider][storage.prefix];\n\t\tif (list.length) loadNewIcons(storage, list);\n\t});\n\treturn callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\n/**\n* Load one icon using Promise\n*/\nconst loadIcon = (icon) => {\n\treturn new Promise((fulfill, reject) => {\n\t\tconst iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n\t\tif (!iconObj) {\n\t\t\treject(icon);\n\t\t\treturn;\n\t\t}\n\t\tloadIcons([iconObj || icon], (loaded) => {\n\t\t\tif (loaded.length && iconObj) {\n\t\t\t\tconst data = getIconData(iconObj);\n\t\t\t\tif (data) {\n\t\t\t\t\tfulfill({\n\t\t\t\t\t\t...defaultIconProps,\n\t\t\t\t\t\t...data\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(icon);\n\t\t});\n\t});\n};\n\n/**\n* Set custom loader for multiple icons\n*/\nfunction setCustomIconsLoader(loader, prefix, provider) {\n\tgetStorage(provider || \"\", prefix).loadIcons = loader;\n}\n/**\n* Set custom loader for one icon\n*/\nfunction setCustomIconLoader(loader, prefix, provider) {\n\tgetStorage(provider || \"\", prefix).loadIcon = loader;\n}\n\n/**\n* Convert IconifyIconCustomisations to FullIconCustomisations, checking value types\n*/\nfunction mergeCustomisations(defaults, item) {\n\tconst result = { ...defaults };\n\tfor (const key in item) {\n\t\tconst value = item[key];\n\t\tconst valueType = typeof value;\n\t\tif (key in defaultIconSizeCustomisations) {\n\t\t\tif (value === null || value && (valueType === \"string\" || valueType === \"number\")) result[key] = value;\n\t\t} else if (valueType === typeof result[key]) result[key] = key === \"rotate\" ? value % 4 : value;\n\t}\n\treturn result;\n}\n\nconst separator = /[\\s,]+/;\n/**\n* Apply \"flip\" string to icon customisations\n*/\nfunction flipFromString(custom, flip) {\n\tflip.split(separator).forEach((str) => {\n\t\tconst value = str.trim();\n\t\tswitch (value) {\n\t\t\tcase \"horizontal\":\n\t\t\t\tcustom.hFlip = true;\n\t\t\t\tbreak;\n\t\t\tcase \"vertical\":\n\t\t\t\tcustom.vFlip = true;\n\t\t\t\tbreak;\n\t\t}\n\t});\n}\n\n/**\n* Get rotation value\n*/\nfunction rotateFromString(value, defaultValue = 0) {\n\tconst units = value.replace(/^-?[0-9.]*/, \"\");\n\tfunction cleanup(value$1) {\n\t\twhile (value$1 < 0) value$1 += 4;\n\t\treturn value$1 % 4;\n\t}\n\tif (units === \"\") {\n\t\tconst num = parseInt(value);\n\t\treturn isNaN(num) ? 0 : cleanup(num);\n\t} else if (units !== value) {\n\t\tlet split = 0;\n\t\tswitch (units) {\n\t\t\tcase \"%\":\n\t\t\t\tsplit = 25;\n\t\t\t\tbreak;\n\t\t\tcase \"deg\": split = 90;\n\t\t}\n\t\tif (split) {\n\t\t\tlet num = parseFloat(value.slice(0, value.length - units.length));\n\t\t\tif (isNaN(num)) return 0;\n\t\t\tnum = num / split;\n\t\t\treturn num % 1 === 0 ? cleanup(num) : 0;\n\t\t}\n\t}\n\treturn defaultValue;\n}\n\n/**\n* Generate <svg>\n*/\nfunction iconToHTML(body, attributes) {\n\tlet renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : \" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\";\n\tfor (const attr in attributes) renderAttribsHTML += \" \" + attr + \"=\\\"\" + attributes[attr] + \"\\\"\";\n\treturn \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\" + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\n\n/**\n* Encode SVG for use in url()\n*\n* Short alternative to encodeURIComponent() that encodes only stuff used in SVG, generating\n* smaller code.\n*/\nfunction encodeSVGforURL(svg) {\n\treturn svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\n/**\n* Generate data: URL from SVG\n*/\nfunction svgToData(svg) {\n\treturn \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\n/**\n* Generate url() from SVG\n*/\nfunction svgToURL(svg) {\n\treturn \"url(\\\"\" + svgToData(svg) + \"\\\")\";\n}\n\nlet policy;\n/**\n* Attempt to create policy\n*/\nfunction createPolicy() {\n\ttry {\n\t\tpolicy = window.trustedTypes.createPolicy(\"iconify\", { createHTML: (s) => s });\n\t} catch (err) {\n\t\tpolicy = null;\n\t}\n}\n/**\n* Clean up value for innerHTML assignment\n*\n* This code doesn't actually clean up anything.\n* It is intended be used with Iconify icon data, which has already been validated\n*/\nfunction cleanUpInnerHTML(html) {\n\tif (policy === void 0) createPolicy();\n\treturn policy ? policy.createHTML(html) : html;\n}\n\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false,\n};\n\n/**\n * Default SVG attributes\n */\nconst svgDefaults = {\n    'xmlns': 'http://www.w3.org/2000/svg',\n    'xmlnsXlink': 'http://www.w3.org/1999/xlink',\n    'aria-hidden': true,\n    'role': 'img',\n};\n/**\n * Style modes\n */\nconst commonProps = {\n    display: 'inline-block',\n};\nconst monotoneProps = {\n    backgroundColor: 'currentColor',\n};\nconst coloredProps = {\n    backgroundColor: 'transparent',\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    Image: 'var(--svg)',\n    Repeat: 'no-repeat',\n    Size: '100% 100%',\n};\nconst propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps,\n};\nfor (const prefix in propsToAddTo) {\n    const list = propsToAddTo[prefix];\n    for (const prop in propsToAdd) {\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */\nconst inlineDefaults = {\n    ...defaultExtendedIconCustomisations,\n    inline: true,\n};\n/**\n * Fix size: add 'px' to numbers\n */\nfunction fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? 'px' : '');\n}\n/**\n * Render icon\n */\nconst render = (\n// Icon must be validated before calling this function\nicon, \n// Partial properties\nprops, \n// Icon name\nname) => {\n    // Get default properties\n    const defaultProps = props.inline\n        ? inlineDefaults\n        : defaultExtendedIconCustomisations;\n    // Get all customisations\n    const customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    const mode = props.mode || 'svg';\n    // Create style\n    const style = {};\n    const customStyle = props.style || {};\n    // Create SVG component properties\n    const componentProps = {\n        ...(mode === 'svg' ? svgDefaults : {}),\n    };\n    if (name) {\n        const iconName = stringToIcon(name, false, true);\n        if (iconName) {\n            const classNames = ['iconify'];\n            const props = [\n                'provider',\n                'prefix',\n            ];\n            for (const prop of props) {\n                if (iconName[prop]) {\n                    classNames.push('iconify--' + iconName[prop]);\n                }\n            }\n            componentProps.className = classNames.join(' ');\n        }\n    }\n    // Get element properties\n    for (let key in props) {\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch (key) {\n            // Properties to ignore\n            case 'icon':\n            case 'style':\n            case 'children':\n            case 'onLoad':\n            case 'mode':\n            case 'ssr':\n            case 'fallback':\n                break;\n            // Forward ref\n            case '_ref':\n                componentProps.ref = value;\n                break;\n            // Merge class names\n            case 'className':\n                componentProps[key] =\n                    (componentProps[key] ? componentProps[key] + ' ' : '') +\n                        value;\n                break;\n            // Boolean attributes\n            case 'inline':\n            case 'hFlip':\n            case 'vFlip':\n                customisations[key] =\n                    value === true || value === 'true' || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case 'flip':\n                if (typeof value === 'string') {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case 'color':\n                style.color = value;\n                break;\n            // Rotation as string\n            case 'rotate':\n                if (typeof value === 'string') {\n                    customisations[key] = rotateFromString(value);\n                }\n                else if (typeof value === 'number') {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case 'ariaHidden':\n            case 'aria-hidden':\n                if (value !== true && value !== 'true') {\n                    delete componentProps['aria-hidden'];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = '-0.125em';\n    }\n    if (mode === 'svg') {\n        // Add style\n        componentProps.style = {\n            ...style,\n            ...customStyle,\n        };\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === 'string') {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, '_');\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? () => id + 'ID' + localCounter++ : 'iconifyReact')),\n        };\n        return createElement('svg', componentProps);\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === 'mask' ||\n        (mode === 'bg' ? false : body.indexOf('currentColor') !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + '',\n        height: height + '',\n    });\n    // Generate style\n    componentProps.style = {\n        ...style,\n        '--svg': svgToURL(html),\n        'width': fixSize(renderAttribs.width),\n        'height': fixSize(renderAttribs.height),\n        ...commonProps,\n        ...(useMask ? monotoneProps : coloredProps),\n        ...customStyle,\n    };\n    return createElement('span', componentProps);\n};\n\n/**\n * Initialise stuff\n */\n// Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule('', fetchAPIModule);\n/**\n * Browser stuff\n */\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\n    const _window = window;\n    // Load icons from global \"IconifyPreload\"\n    if (_window.IconifyPreload !== void 0) {\n        const preload = _window.IconifyPreload;\n        const err = 'Invalid IconifyPreload syntax.';\n        if (typeof preload === 'object' && preload !== null) {\n            (preload instanceof Array ? preload : [preload]).forEach((item) => {\n                try {\n                    if (\n                    // Check if item is an object and not null/array\n                    typeof item !== 'object' ||\n                        item === null ||\n                        item instanceof Array ||\n                        // Check for 'icons' and 'prefix'\n                        typeof item.icons !== 'object' ||\n                        typeof item.prefix !== 'string' ||\n                        // Add icon set\n                        !addCollection(item)) {\n                        console.error(err);\n                    }\n                }\n                catch (e) {\n                    console.error(err);\n                }\n            });\n        }\n    }\n    // Set API from global \"IconifyProviders\"\n    if (_window.IconifyProviders !== void 0) {\n        const providers = _window.IconifyProviders;\n        if (typeof providers === 'object' && providers !== null) {\n            for (let key in providers) {\n                const err = 'IconifyProviders[' + key + '] is invalid.';\n                try {\n                    const value = providers[key];\n                    if (typeof value !== 'object' ||\n                        !value ||\n                        value.resources === void 0) {\n                        continue;\n                    }\n                    if (!addAPIProvider(key, value)) {\n                        console.error(err);\n                    }\n                }\n                catch (e) {\n                    console.error(err);\n                }\n            }\n        }\n    }\n}\nfunction IconComponent(props) {\n    const [mounted, setMounted] = useState(!!props.ssr);\n    const [abort, setAbort] = useState({});\n    // Get initial state\n    function getInitialState(mounted) {\n        if (mounted) {\n            const name = props.icon;\n            if (typeof name === 'object') {\n                // Icon as object\n                return {\n                    name: '',\n                    data: name,\n                };\n            }\n            const data = getIconData(name);\n            if (data) {\n                return {\n                    name,\n                    data,\n                };\n            }\n        }\n        return {\n            name: '',\n        };\n    }\n    const [state, setState] = useState(getInitialState(!!props.ssr));\n    // Cancel loading\n    function cleanup() {\n        const callback = abort.callback;\n        if (callback) {\n            callback();\n            setAbort({});\n        }\n    }\n    // Change state if it is different\n    function changeState(newState) {\n        if (JSON.stringify(state) !== JSON.stringify(newState)) {\n            cleanup();\n            setState(newState);\n            return true;\n        }\n    }\n    // Update state\n    function updateState() {\n        var _a;\n        const name = props.icon;\n        if (typeof name === 'object') {\n            // Icon as object\n            changeState({\n                name: '',\n                data: name,\n            });\n            return;\n        }\n        // New icon or got icon data\n        const data = getIconData(name);\n        if (changeState({\n            name,\n            data,\n        })) {\n            if (data === undefined) {\n                // Load icon, update state when done\n                const callback = loadIcons([name], updateState);\n                setAbort({\n                    callback,\n                });\n            }\n            else if (data) {\n                // Icon data is available: trigger onLoad callback if present\n                (_a = props.onLoad) === null || _a === void 0 ? void 0 : _a.call(props, name);\n            }\n        }\n    }\n    // Mounted state, cleanup for loader\n    useEffect(() => {\n        setMounted(true);\n        return cleanup;\n    }, []);\n    // Icon changed or component mounted\n    useEffect(() => {\n        if (mounted) {\n            updateState();\n        }\n    }, [props.icon, mounted]);\n    // Render icon\n    const { name, data } = state;\n    if (!data) {\n        return props.children\n            ? props.children\n            : props.fallback\n                ? props.fallback\n                : createElement('span', {});\n    }\n    return render({\n        ...defaultIconProps,\n        ...data,\n    }, props, name);\n}\n/**\n * Block icon\n *\n * @param props - Component properties\n */\nconst Icon = forwardRef((props, ref) => IconComponent({\n    ...props,\n    _ref: ref,\n}));\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */\nconst InlineIcon = forwardRef((props, ref) => IconComponent({\n    inline: true,\n    ...props,\n    _ref: ref,\n}));\n/**\n * Internal API\n */\nconst _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders,\n};\n\nexport { Icon, InlineIcon, _api, addAPIProvider, addCollection, addIcon, iconToSVG as buildIcon, calculateSize, getIcon, iconLoaded, listIcons, loadIcon, loadIcons, replaceIDs, setCustomIconLoader, setCustomIconsLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}